{"title": "分享丨【题单】常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）", "src": "https://leetcode.cn/circle/discuss/mOr1u6", "last_update": "2025-03-10T14:10:55.112117+00:00", "children": [{"title": "介绍", "summary": "题目已按照难度分排序，右侧数字为难度分。<br>如果遇到难度很大，题解都看不懂的题目，建议直接跳过，二刷的时候再来尝试。<br><img src=\"https://pic.leetcode.cn/1713836847-cDYwhf-Programming.jfif\" alt=\"数据结构题单 数据结构入门 数据结构新手教程 数据结构题目 力扣数据结构 leetcode数据结构 灵茶山艾府 灵神\" style=\"width: 100%;\"><br>", "isLeaf": false, "children": [{"title": "零、常用枚举技巧", "summary": "", "isLeaf": false, "children": [{"title": "§0.1 枚举右，维护左", "summary": "对于 **双变量问题**，例如两数之和 $a_i+a_j=t$，可以枚举右边的 $a_j$，转换成 **单变量问题**，也就是在 $a_j$ 左边查找是否有 $a_i = t-a_j$，这可以用哈希表维护。<br>我把这个技巧叫做 **枚举右，维护左**。<br><a href=\"https://leetcode.cn/problems/two-sum/solution/dong-hua-cong-liang-shu-zhi-he-zhong-wo-0yvmj/\">讲解</a><br>**思维扩展**：<br>", "isLeaf": true, "children": [], "problems": [{"id": 1, "title": "1. 两数之和", "slug": "/two-sum/", "src": "https://leetcode.cn/problems/two-sum/", "solution": null, "score": null, "isPremium": false}, {"id": 1512, "title": "1512. 好数对的数目", "slug": "/number-of-good-pairs/", "src": "https://leetcode.cn/problems/number-of-good-pairs/", "solution": null, "score": 1160.8899403409, "isPremium": false}, {"id": 2001, "title": "2001. 可互换矩形的组数", "slug": "/number-of-pairs-of-interchangeable-rectangles/", "src": "https://leetcode.cn/problems/number-of-pairs-of-interchangeable-rectangles/", "solution": null, "score": 1435.9559888935, "isPremium": false}, {"id": 121, "title": "121. 买卖股票的最佳时机", "slug": "/best-time-to-buy-and-sell-stock/", "src": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/", "solution": null, "score": null, "isPremium": false}, {"id": 2342, "title": "2342. 数位和相等数对的最大和", "slug": "/max-sum-of-a-pair-with-equal-sum-of-digits/", "src": "https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/", "solution": null, "score": 1308.9617729374, "isPremium": false}, {"id": 2815, "title": "2815. 数组中的最大数对和", "slug": "/max-pair-sum-in-an-array/", "src": "https://leetcode.cn/problems/max-pair-sum-in-an-array/", "solution": null, "score": 1295.0947625986, "isPremium": false}, {"id": 1679, "title": "1679. K 和数对的最大数目", "slug": "/max-number-of-k-sum-pairs/", "src": "https://leetcode.cn/problems/max-number-of-k-sum-pairs/", "solution": null, "score": 1345.737168609, "isPremium": false}, {"id": 219, "title": "219. 存在重复元素 II", "slug": "/contains-duplicate-ii/", "src": "https://leetcode.cn/problems/contains-duplicate-ii/", "solution": null, "score": null, "isPremium": false}, {"id": 2260, "title": "2260. 必须拿起的最小连续卡牌数", "slug": "/minimum-consecutive-cards-to-pick-up/", "src": "https://leetcode.cn/problems/minimum-consecutive-cards-to-pick-up/", "solution": null, "score": 1364.6787168645, "isPremium": false}, {"id": 624, "title": "624. 数组列表中的最大距离", "slug": "/maximum-distance-in-arrays/", "src": "https://leetcode.cn/problems/maximum-distance-in-arrays/", "solution": null, "score": null, "isPremium": false}, {"id": 1010, "title": "1010. 总持续时间可被 60 整除的歌曲", "slug": "/pairs-of-songs-with-total-durations-divisible-by-60/", "src": "https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/", "solution": null, "score": 1377.1913915125, "isPremium": false}, {"id": 3185, "title": "3185. 构成整天的下标对数目 II", "slug": "/count-pairs-that-form-a-complete-day-ii/", "src": "https://leetcode.cn/problems/count-pairs-that-form-a-complete-day-ii/", "solution": null, "score": 1385.2857255388, "isPremium": false}, {"id": 2506, "title": "2506. 统计相似字符串对的数目", "slug": "/count-pairs-of-similar-strings/", "src": "https://leetcode.cn/problems/count-pairs-of-similar-strings/", "solution": null, "score": 1335.4613368501, "isPremium": false}, {"id": 2748, "title": "2748. 美丽下标对的数目", "slug": "/number-of-beautiful-pairs/", "src": "https://leetcode.cn/problems/number-of-beautiful-pairs/", "solution": null, "score": 1301.1576743638, "isPremium": false}, {"id": 2874, "title": "2874. 有序三元组中的最大值 II", "slug": "/maximum-value-of-an-ordered-triplet-ii/", "src": "https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/", "solution": null, "score": 1583.212966224, "isPremium": false}, {"id": 3371, "title": "3371. 识别数组中的最大异常值", "slug": "/identify-the-largest-outlier-in-an-array/", "src": "https://leetcode.cn/problems/identify-the-largest-outlier-in-an-array/", "solution": null, "score": 1643.7450467383, "isPremium": false}, {"id": 1014, "title": "1014. 最佳观光组合", "slug": "/best-sightseeing-pair/", "src": "https://leetcode.cn/problems/best-sightseeing-pair/", "solution": null, "score": 1730.3052054913, "isPremium": false}, {"id": 1814, "title": "1814. 统计一个数组中好对子的数目", "slug": "/count-nice-pairs-in-an-array/", "src": "https://leetcode.cn/problems/count-nice-pairs-in-an-array/", "solution": null, "score": 1737.8431142688, "isPremium": false}, {"id": 2905, "title": "2905. 找出满足差值条件的下标 II", "slug": "/find-indices-with-index-and-value-difference-ii/", "src": "https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/", "solution": null, "score": 1763.787679959, "isPremium": false}, {"id": 1031, "title": "1031. 两个非重叠子数组的最大和", "slug": "/maximum-sum-of-two-non-overlapping-subarrays/", "src": "https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/", "solution": null, "score": 1680.4852623991, "isPremium": false}, {"id": 2555, "title": "2555. 两个线段获得的最多奖品", "slug": "/maximize-win-from-two-segments/", "src": "https://leetcode.cn/problems/maximize-win-from-two-segments/", "solution": null, "score": 2080.7845644831, "isPremium": false}, {"id": 1995, "title": "1995. 统计特殊四元组", "slug": "/count-special-quadruplets/", "src": "https://leetcode.cn/problems/count-special-quadruplets/", "solution": null, "score": 1352.1791099256, "isPremium": false}, {"id": 3404, "title": "3404. 统计特殊子序列的数目", "slug": "/count-special-subsequences/", "src": "https://leetcode.cn/problems/count-special-subsequences/", "solution": null, "score": 2445.3859371333, "isPremium": false}, {"id": 3267, "title": "3267. 统计近似相等数对 II", "slug": "/count-almost-equal-pairs-ii/", "src": "https://leetcode.cn/problems/count-almost-equal-pairs-ii/", "solution": null, "score": 2545.1080433595, "isPremium": false}, {"id": 1214, "title": "1214. 查找两棵二叉搜索树之和", "slug": "/two-sum-bsts/", "src": "https://leetcode.cn/problems/two-sum-bsts/", "solution": null, "score": 1389.0328392117, "isPremium": true}, {"id": 2964, "title": "2964. 可被整除的三元组数量", "slug": "/number-of-divisible-triplet-sums/", "src": "https://leetcode.cn/problems/number-of-divisible-triplet-sums/", "solution": null, "score": null, "isPremium": true}, {"id": 2441, "title": "2441. 与对应负数同时存在的最大正整数", "slug": "/largest-positive-integer-that-exists-with-its-negative/", "src": "https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/", "solution": null, "score": 1167.647122501, "isPremium": false}, {"id": "面试题 16.24", "title": "面试题 16.24. 数对和", "slug": "/pairs-with-sum-lcci/", "src": "https://leetcode.cn/problems/pairs-with-sum-lcci/", "solution": null, "score": null, "isPremium": false}, {"id": 454, "title": "454. 四数相加 II", "slug": "/4sum-ii/", "src": "https://leetcode.cn/problems/4sum-ii/", "solution": null, "score": null, "isPremium": false}]}, {"title": "§0.2 枚举中间", "summary": "对于三个或者四个变量的问题，枚举中间的变量往往更好算。<br>", "isLeaf": true, "children": [], "problems": [{"id": 2909, "title": "2909. 元素和最小的山形三元组 II", "slug": "/minimum-sum-of-mountain-triplets-ii/", "src": "https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/", "solution": null, "score": 1478.8676835951, "isPremium": false}, {"id": 1930, "title": "1930. 长度为 3 的不同回文子序列", "slug": "/unique-length-3-palindromic-subsequences/", "src": "https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/", "solution": null, "score": 1533.3376144199, "isPremium": false}, {"id": 3128, "title": "3128. 直角三角形", "slug": "/right-triangles/", "src": "https://leetcode.cn/problems/right-triangles/", "solution": null, "score": 1540.8447688369, "isPremium": false}, {"id": 2874, "title": "2874. 有序三元组中的最大值 II", "slug": "/maximum-value-of-an-ordered-triplet-ii/", "src": "https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/", "solution": null, "score": 1583.212966224, "isPremium": false}, {"id": 447, "title": "447. 回旋镖的数量", "slug": "/number-of-boomerangs/", "src": "https://leetcode.cn/problems/number-of-boomerangs/", "solution": null, "score": null, "isPremium": false}, {"id": 456, "title": "456. 132 模式", "slug": "/132-pattern/", "src": "https://leetcode.cn/problems/132-pattern/", "solution": null, "score": null, "isPremium": false}, {"id": 3067, "title": "3067. 在带权树网络中统计可连接服务器对数目", "slug": "/count-pairs-of-connectable-servers-in-a-weighted-tree-network/", "src": "https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/", "solution": null, "score": 1908.9411092109, "isPremium": false}, {"id": 3455, "title": "3455. 最短匹配子字符串", "slug": "/shortest-matching-substring/", "src": "https://leetcode.cn/problems/shortest-matching-substring/", "solution": null, "score": null, "isPremium": false}, {"id": 2242, "title": "2242. 节点序列的最大得分", "slug": "/maximum-score-of-a-node-sequence/", "src": "https://leetcode.cn/problems/maximum-score-of-a-node-sequence/", "solution": null, "score": 2304.3094138939, "isPremium": false}, {"id": 2867, "title": "2867. 统计树中的合法路径数目", "slug": "/count-valid-paths-in-a-tree/", "src": "https://leetcode.cn/problems/count-valid-paths-in-a-tree/", "solution": null, "score": 2428.3242593838, "isPremium": false}, {"id": 2552, "title": "2552. 统计上升四元组", "slug": "/count-increasing-quadruplets/", "src": "https://leetcode.cn/problems/count-increasing-quadruplets/", "solution": null, "score": 2432.713399111, "isPremium": false}, {"id": 3257, "title": "3257. 放三个车的价值之和最大 II", "slug": "/maximum-value-sum-by-placing-three-rooks-ii/", "src": "https://leetcode.cn/problems/maximum-value-sum-by-placing-three-rooks-ii/", "solution": null, "score": 2553.2367142614, "isPremium": false}, {"id": 3073, "title": "3073. 最大递增三元组", "slug": "/maximum-increasing-triplet-value/", "src": "https://leetcode.cn/problems/maximum-increasing-triplet-value/", "solution": null, "score": null, "isPremium": true}]}], "problems": []}, {"title": "一、前缀和", "summary": "", "isLeaf": false, "children": [{"title": "§1.1 前缀和基础", "summary": "<a href=\"https://leetcode.cn/problems/range-sum-query-immutable/solution/qian-zhui-he-ji-qi-kuo-zhan-fu-ti-dan-py-vaar/\">讲解</a><br>**思维扩展**：<br>", "isLeaf": true, "children": [], "problems": [{"id": 303, "title": "303. 区域和检索 - 数组不可变", "slug": "/range-sum-query-immutable/", "src": "https://leetcode.cn/problems/range-sum-query-immutable/", "solution": null, "score": null, "isPremium": false}, {"id": 3427, "title": "3427. 变长子数组求和", "slug": "/sum-of-variable-length-subarrays/", "src": "https://leetcode.cn/problems/sum-of-variable-length-subarrays/", "solution": null, "score": 1215.6806967423, "isPremium": false}, {"id": 2559, "title": "2559. 统计范围内的元音字符串数", "slug": "/count-vowel-strings-in-ranges/", "src": "https://leetcode.cn/problems/count-vowel-strings-in-ranges/", "solution": null, "score": 1435.0179887342, "isPremium": false}, {"id": 3152, "title": "3152. 特殊数组 II", "slug": "/special-array-ii/", "src": "https://leetcode.cn/problems/special-array-ii/", "solution": null, "score": 1523.2643084719, "isPremium": false}, {"id": 1749, "title": "1749. 任意子数组和的绝对值的最大值", "slug": "/maximum-absolute-sum-of-any-subarray/", "src": "https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/", "solution": null, "score": 1541.6176288991, "isPremium": false}, {"id": 2389, "title": "2389. 和有限的最长子序列", "slug": "/longest-subsequence-with-limited-sum/", "src": "https://leetcode.cn/problems/longest-subsequence-with-limited-sum/", "solution": null, "score": 1387.7347071166, "isPremium": false}, {"id": 3361, "title": "3361. 两个字符串的切换距离", "slug": "/shift-distance-between-two-strings/", "src": "https://leetcode.cn/problems/shift-distance-between-two-strings/", "solution": null, "score": 1553.2232121523, "isPremium": false}, {"id": 2055, "title": "2055. 蜡烛之间的盘子", "slug": "/plates-between-candles/", "src": "https://leetcode.cn/problems/plates-between-candles/", "solution": null, "score": 1819.3068421506, "isPremium": false}, {"id": 1744, "title": "1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？", "slug": "/can-you-eat-your-favorite-candy-on-your-favorite-day/", "src": "https://leetcode.cn/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/", "solution": null, "score": 1858.9581916885, "isPremium": false}, {"id": 53, "title": "53. 最大子数组和", "slug": "/maximum-subarray/", "src": "https://leetcode.cn/problems/maximum-subarray/", "solution": null, "score": null, "isPremium": false}, {"id": 1523, "title": "1523. 在区间范围内统计奇数数目", "slug": "/count-odd-numbers-in-an-interval-range/", "src": "https://leetcode.cn/problems/count-odd-numbers-in-an-interval-range/", "solution": null, "score": 1209.3722198224, "isPremium": false}]}, {"title": "§1.2 前缀和与哈希表", "summary": "通常要用到「枚举右，维护左」的技巧。<br><a href=\"https://leetcode.cn/problems/subarray-sum-equals-k/solution/qian-zhui-he-ha-xi-biao-cong-liang-ci-bi-4mwr/\">讲解</a><br>**前缀和与有序集合**：<br>**思维扩展**：<br>", "isLeaf": true, "children": [], "problems": [{"id": 930, "title": "930. 和相同的二元子数组", "slug": "/binary-subarrays-with-sum/", "src": "https://leetcode.cn/problems/binary-subarrays-with-sum/", "solution": null, "score": 1591.5492530876, "isPremium": false}, {"id": 560, "title": "560. 和为 K 的子数组", "slug": "/subarray-sum-equals-k/", "src": "https://leetcode.cn/problems/subarray-sum-equals-k/", "solution": null, "score": null, "isPremium": false}, {"id": 1524, "title": "1524. 和为奇数的子数组数目", "slug": "/number-of-sub-arrays-with-odd-sum/", "src": "https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/", "solution": null, "score": 1610.569398159, "isPremium": false}, {"id": 974, "title": "974. 和可被 K 整除的子数组", "slug": "/subarray-sums-divisible-by-k/", "src": "https://leetcode.cn/problems/subarray-sums-divisible-by-k/", "solution": null, "score": 1675.989407584, "isPremium": false}, {"id": 523, "title": "523. 连续的子数组和", "slug": "/continuous-subarray-sum/", "src": "https://leetcode.cn/problems/continuous-subarray-sum/", "solution": null, "score": null, "isPremium": false}, {"id": 437, "title": "437. 路径总和 III", "slug": "/path-sum-iii/", "src": "https://leetcode.cn/problems/path-sum-iii/", "solution": null, "score": null, "isPremium": false}, {"id": 2588, "title": "2588. 统计美丽子数组数目", "slug": "/count-the-number-of-beautiful-subarrays/", "src": "https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/", "solution": null, "score": 1696.8895579594, "isPremium": false}, {"id": 525, "title": "525. 连续数组", "slug": "/contiguous-array/", "src": "https://leetcode.cn/problems/contiguous-array/", "solution": null, "score": null, "isPremium": false}, {"id": "面试题 17.05", "title": "面试题 17.05. 字母与数字", "slug": "/find-longest-subarray-lcci/", "src": "https://leetcode.cn/problems/find-longest-subarray-lcci/", "solution": null, "score": null, "isPremium": false}, {"id": 3026, "title": "3026. 最大好子数组和", "slug": "/maximum-good-subarray-sum/", "src": "https://leetcode.cn/problems/maximum-good-subarray-sum/", "solution": null, "score": 1816.556997127, "isPremium": false}, {"id": 1477, "title": "1477. 找两个和为目标值且不重叠的子数组", "slug": "/find-two-non-overlapping-sub-arrays-each-with-target-sum/", "src": "https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/", "solution": null, "score": 1850.5506342426, "isPremium": false}, {"id": 1546, "title": "1546. 和为目标值且不重叠的非空子数组的最大数目", "slug": "/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/", "src": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/", "solution": null, "score": 1855.377046154, "isPremium": false}, {"id": 1124, "title": "1124. 表现良好的最长时间段", "slug": "/longest-well-performing-interval/", "src": "https://leetcode.cn/problems/longest-well-performing-interval/", "solution": null, "score": 1908.3866125757, "isPremium": false}, {"id": 3381, "title": "3381. 长度可被 K 整除的子数组的最大元素和", "slug": "/maximum-subarray-sum-with-length-divisible-by-k/", "src": "https://leetcode.cn/problems/maximum-subarray-sum-with-length-divisible-by-k/", "solution": null, "score": 1943.095489145, "isPremium": false}, {"id": 2488, "title": "2488. 统计中位数为 K 的子数组", "slug": "/count-subarrays-with-median-k/", "src": "https://leetcode.cn/problems/count-subarrays-with-median-k/", "solution": null, "score": 1998.889914712, "isPremium": false}, {"id": 1590, "title": "1590. 使数组和能被 P 整除", "slug": "/make-sum-divisible-by-p/", "src": "https://leetcode.cn/problems/make-sum-divisible-by-p/", "solution": null, "score": 2038.8592725467, "isPremium": false}, {"id": 2845, "title": "2845. 统计趣味子数组的数目", "slug": "/count-of-interesting-subarrays/", "src": "https://leetcode.cn/problems/count-of-interesting-subarrays/", "solution": null, "score": 2073.048019317, "isPremium": false}, {"id": 1442, "title": "1442. 形成两个异或相等数组的三元组数目", "slug": "/count-triplets-that-can-form-two-arrays-of-equal-xor/", "src": "https://leetcode.cn/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/", "solution": null, "score": 1524.5693481538, "isPremium": false}, {"id": 2949, "title": "2949. 统计美丽子字符串 II", "slug": "/count-beautiful-substrings-ii/", "src": "https://leetcode.cn/problems/count-beautiful-substrings-ii/", "solution": null, "score": 2444.7192647604, "isPremium": false}, {"id": 325, "title": "325. 和等于 k 的最长子数组长度", "slug": "/maximum-size-subarray-sum-equals-k/", "src": "https://leetcode.cn/problems/maximum-size-subarray-sum-equals-k/", "solution": null, "score": null, "isPremium": true}, {"id": 548, "title": "548. 将数组分割成和相等的子数组", "slug": "/split-array-with-equal-sum/", "src": "https://leetcode.cn/problems/split-array-with-equal-sum/", "solution": null, "score": null, "isPremium": true}, {"id": 1983, "title": "1983. 范围和相等的最宽索引对", "slug": "/widest-pair-of-indices-with-equal-range-sum/", "src": "https://leetcode.cn/problems/widest-pair-of-indices-with-equal-range-sum/", "solution": null, "score": null, "isPremium": true}, {"id": 2489, "title": "2489. 固定比率的子字符串数", "slug": "/number-of-substrings-with-fixed-ratio/", "src": "https://leetcode.cn/problems/number-of-substrings-with-fixed-ratio/", "solution": null, "score": null, "isPremium": true}, {"id": 2950, "title": "2950. 可整除子串的数量", "slug": "/number-of-divisible-substrings/", "src": "https://leetcode.cn/problems/number-of-divisible-substrings/", "solution": null, "score": null, "isPremium": true}, {"id": 3364, "title": "3364. 最小正和子数组", "slug": "/minimum-positive-sum-subarray/", "src": "https://leetcode.cn/problems/minimum-positive-sum-subarray/", "solution": null, "score": 1300.5576941005, "isPremium": false}, {"id": 2025, "title": "2025. 分割数组的最多方案数", "slug": "/maximum-number-of-ways-to-partition-an-array/", "src": "https://leetcode.cn/problems/maximum-number-of-ways-to-partition-an-array/", "solution": null, "score": 2217.8090802563, "isPremium": false}]}, {"title": "§1.3 距离和", "summary": "<a href=\"https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solution/yi-tu-miao-dong-pai-xu-qian-zhui-he-er-f-nf55/\">图解</a><br>", "isLeaf": true, "children": [], "problems": [{"id": 1685, "title": "1685. 有序数组中差绝对值之和", "slug": "/sum-of-absolute-differences-in-a-sorted-array/", "src": "https://leetcode.cn/problems/sum-of-absolute-differences-in-a-sorted-array/", "solution": null, "score": 1495.715740828, "isPremium": false}, {"id": 2615, "title": "2615. 等值距离和", "slug": "/sum-of-distances/", "src": "https://leetcode.cn/problems/sum-of-distances/", "solution": null, "score": 1793.3033536992, "isPremium": false}, {"id": 2602, "title": "2602. 使数组元素全部相等的最少操作次数", "slug": "/minimum-operations-to-make-all-array-elements-equal/", "src": "https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/", "solution": null, "score": 1903.1973989877, "isPremium": false}, {"id": 2968, "title": "2968. 执行操作使频率分数最大", "slug": "/apply-operations-to-maximize-frequency-score/", "src": "https://leetcode.cn/problems/apply-operations-to-maximize-frequency-score/", "solution": null, "score": 2444.2791027022, "isPremium": false}, {"id": 1703, "title": "1703. 得到连续 K 个 1 的最少相邻交换次数", "slug": "/minimum-adjacent-swaps-for-k-consecutive-ones/", "src": "https://leetcode.cn/problems/minimum-adjacent-swaps-for-k-consecutive-ones/", "solution": null, "score": 2466.8891773908, "isPremium": false}, {"id": 3086, "title": "3086. 拾起 K 个 1 需要的最少行动次数", "slug": "/minimum-moves-to-pick-k-ones/", "src": "https://leetcode.cn/problems/minimum-moves-to-pick-k-ones/", "solution": null, "score": 2672.7613091907, "isPremium": false}, {"id": 3422, "title": "3422. 将子数组元素变为相等所需的最小操作数", "slug": "/minimum-operations-to-make-subarray-elements-equal/", "src": "https://leetcode.cn/problems/minimum-operations-to-make-subarray-elements-equal/", "solution": null, "score": null, "isPremium": true}]}, {"title": "§1.4 前缀异或和", "summary": "推荐先阅读：<a href=\"https://leetcode.cn/circle/discuss/CaOJ45/\">从集合论到位运算，常见位运算技巧分类总结！</a><br>", "isLeaf": true, "children": [], "problems": [{"id": 1177, "title": "1177. 构建回文串检测", "slug": "/can-make-palindrome-from-substring/", "src": "https://leetcode.cn/problems/can-make-palindrome-from-substring/", "solution": null, "score": 1848.0912848518, "isPremium": false}, {"id": 1371, "title": "1371. 每个元音包含偶数次的最长子字符串", "slug": "/find-the-longest-substring-containing-vowels-in-even-counts/", "src": "https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/", "solution": null, "score": 2040.539289037, "isPremium": false}, {"id": 1542, "title": "1542. 找出最长的超赞子字符串", "slug": "/find-longest-awesome-substring/", "src": "https://leetcode.cn/problems/find-longest-awesome-substring/", "solution": null, "score": 2221.7336557442, "isPremium": false}, {"id": 1915, "title": "1915. 最美子字符串的数目", "slug": "/number-of-wonderful-substrings/", "src": "https://leetcode.cn/problems/number-of-wonderful-substrings/", "solution": null, "score": 2234.9191877602, "isPremium": false}, {"id": 2791, "title": "2791. 树中可以形成回文的路径数", "slug": "/count-paths-that-can-form-a-palindrome-in-a-tree/", "src": "https://leetcode.cn/problems/count-paths-that-can-form-a-palindrome-in-a-tree/", "solution": null, "score": 2677.1682592316, "isPremium": false}]}, {"title": "§1.5 其他一维前缀和", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 1310, "title": "1310. 子数组异或查询", "slug": "/xor-queries-of-a-subarray/", "src": "https://leetcode.cn/problems/xor-queries-of-a-subarray/", "solution": null, "score": 1459.8208951847, "isPremium": false}, {"id": 2438, "title": "2438. 二的幂数组中查询范围内的乘积", "slug": "/range-product-queries-of-powers/", "src": "https://leetcode.cn/problems/range-product-queries-of-powers/", "solution": null, "score": 1609.7858209851, "isPremium": false}, {"id": 1895, "title": "1895. 最大的幻方", "slug": "/largest-magic-square/", "src": "https://leetcode.cn/problems/largest-magic-square/", "solution": null, "score": 1781.3664141686, "isPremium": false}, {"id": 1878, "title": "1878. 矩阵中最大的三个菱形和", "slug": "/get-biggest-three-rhombus-sums-in-a-grid/", "src": "https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/", "solution": null, "score": 1897.5516652727, "isPremium": false}, {"id": 1031, "title": "1031. 两个非重叠子数组的最大和", "slug": "/maximum-sum-of-two-non-overlapping-subarrays/", "src": "https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/", "solution": null, "score": 1680.4852623991, "isPremium": false}, {"id": 2245, "title": "2245. 转角路径的乘积中最多能有几个尾随零", "slug": "/maximum-trailing-zeros-in-a-cornered-path/", "src": "https://leetcode.cn/problems/maximum-trailing-zeros-in-a-cornered-path/", "solution": null, "score": 2036.7410194704, "isPremium": false}, {"id": 1712, "title": "1712. 将数组分成三个子数组的方案数", "slug": "/ways-to-split-array-into-three-subarrays/", "src": "https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/", "solution": null, "score": 2078.6986769435, "isPremium": false}, {"id": 1862, "title": "1862. 向下取整数对和", "slug": "/sum-of-floored-pairs/", "src": "https://leetcode.cn/problems/sum-of-floored-pairs/", "solution": null, "score": 2170.1079846744, "isPremium": false}, {"id": 363, "title": "363. 矩形区域不超过 K 的最大数值和", "slug": "/max-sum-of-rectangle-no-larger-than-k/", "src": "https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/", "solution": null, "score": null, "isPremium": false}, {"id": 2281, "title": "2281. 巫师的总力量和", "slug": "/sum-of-total-strength-of-wizards/", "src": "https://leetcode.cn/problems/sum-of-total-strength-of-wizards/", "solution": null, "score": 2621.1208072273, "isPremium": false}, {"id": 3445, "title": "3445. 奇偶频次间的最大差值 II", "slug": "/maximum-difference-between-even-and-odd-frequency-ii/", "src": "https://leetcode.cn/problems/maximum-difference-between-even-and-odd-frequency-ii/", "solution": null, "score": null, "isPremium": false}, {"id": 2983, "title": "2983. 回文串重新排列查询", "slug": "/palindrome-rearrangement-queries/", "src": "https://leetcode.cn/problems/palindrome-rearrangement-queries/", "solution": null, "score": 2779.7855167601, "isPremium": false}, {"id": 2955, "title": "2955. 同端子串的数量", "slug": "/number-of-same-end-substrings/", "src": "https://leetcode.cn/problems/number-of-same-end-substrings/", "solution": null, "score": null, "isPremium": true}, {"id": 1788, "title": "1788. 最大化花园的美观度", "slug": "/maximize-the-beauty-of-the-garden/", "src": "https://leetcode.cn/problems/maximize-the-beauty-of-the-garden/", "solution": null, "score": null, "isPremium": true}, {"id": 2819, "title": "2819. 购买巧克力后的最小相对损失", "slug": "/minimum-relative-loss-after-buying-chocolates/", "src": "https://leetcode.cn/problems/minimum-relative-loss-after-buying-chocolates/", "solution": null, "score": null, "isPremium": true}]}, {"title": "§1.6 二维前缀和", "summary": "<a href=\"https://leetcode.cn/problems/range-sum-query-2d-immutable/solution/tu-jie-yi-zhang-tu-miao-dong-er-wei-qian-84qp/\">【图解】一张图秒懂二维前缀和！</a><br>二维前缀最小值：<br>", "isLeaf": true, "children": [], "problems": [{"id": 304, "title": "304. 二维区域和检索 - 矩阵不可变", "slug": "/range-sum-query-2d-immutable/", "src": "https://leetcode.cn/problems/range-sum-query-2d-immutable/", "solution": null, "score": null, "isPremium": false}, {"id": 1314, "title": "1314. 矩阵区域和", "slug": "/matrix-block-sum/", "src": "https://leetcode.cn/problems/matrix-block-sum/", "solution": null, "score": 1483.8137189709, "isPremium": false}, {"id": 3070, "title": "3070. 元素和小于等于 k 的子矩阵的数目", "slug": "/count-submatrices-with-top-left-element-and-sum-less-than-k/", "src": "https://leetcode.cn/problems/count-submatrices-with-top-left-element-and-sum-less-than-k/", "solution": null, "score": 1498.6899053656, "isPremium": false}, {"id": 1738, "title": "1738. 找出第 K 大的异或坐标值", "slug": "/find-kth-largest-xor-coordinate-value/", "src": "https://leetcode.cn/problems/find-kth-largest-xor-coordinate-value/", "solution": null, "score": 1671.4657554194, "isPremium": false}, {"id": 3212, "title": "3212. 统计 X 和 Y 频数相等的子矩阵数量", "slug": "/count-submatrices-with-equal-frequency-of-x-and-y/", "src": "https://leetcode.cn/problems/count-submatrices-with-equal-frequency-of-x-and-y/", "solution": null, "score": 1672.7732068421, "isPremium": false}, {"id": 1292, "title": "1292. 元素和小于等于阈值的正方形的最大边长", "slug": "/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/", "src": "https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/", "solution": null, "score": 1734.8208369949, "isPremium": false}, {"id": 221, "title": "221. 最大正方形", "slug": "/maximal-square/", "src": "https://leetcode.cn/problems/maximal-square/", "solution": null, "score": null, "isPremium": false}, {"id": 1277, "title": "1277. 统计全为 1 的正方形子矩阵", "slug": "/count-square-submatrices-with-all-ones/", "src": "https://leetcode.cn/problems/count-square-submatrices-with-all-ones/", "solution": null, "score": 1613.0429766636, "isPremium": false}, {"id": 1504, "title": "1504. 统计全 1 子矩形", "slug": "/count-submatrices-with-all-ones/", "src": "https://leetcode.cn/problems/count-submatrices-with-all-ones/", "solution": null, "score": 1845.0428731248, "isPremium": false}, {"id": 1074, "title": "1074. 元素和为目标值的子矩阵数量", "slug": "/number-of-submatrices-that-sum-to-target/", "src": "https://leetcode.cn/problems/number-of-submatrices-that-sum-to-target/", "solution": null, "score": 2189.3802630548, "isPremium": false}, {"id": 3148, "title": "3148. 矩阵中的最大得分", "slug": "/maximum-difference-score-in-a-grid/", "src": "https://leetcode.cn/problems/maximum-difference-score-in-a-grid/", "solution": null, "score": 1819.6800324413, "isPremium": false}]}], "problems": []}, {"title": "二、差分", "summary": "", "isLeaf": false, "children": [{"title": "§2.1 一维差分（扫描线）", "summary": "差分与前缀和的关系，类似导数与积分的关系。<br>差分的前缀和就是原数组。<br><a href=\"https://leetcode.cn/problems/car-pooling/solution/suan-fa-xiao-ke-tang-chai-fen-shu-zu-fu-9d4ra/\">原理讲解</a>（推荐和<a href=\"https://leetcode.cn/problems/stamping-the-grid/solution/wu-nao-zuo-fa-er-wei-qian-zhui-he-er-wei-zwiu/\">【图解】从一维差分到二维差分</a> 一起看）<br>", "isLeaf": true, "children": [], "problems": [{"id": 2848, "title": "2848. 与车相交的点", "slug": "/points-that-intersect-with-cars/", "src": "https://leetcode.cn/problems/points-that-intersect-with-cars/", "solution": null, "score": 1229.7575626899, "isPremium": false}, {"id": 1893, "title": "1893. 检查是否区域内所有整数都被覆盖", "slug": "/check-if-all-the-integers-in-a-range-are-covered/", "src": "https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/", "solution": null, "score": 1307.3797385769, "isPremium": false}, {"id": 1854, "title": "1854. 人口最多的年份", "slug": "/maximum-population-year/", "src": "https://leetcode.cn/problems/maximum-population-year/", "solution": null, "score": 1370.4186698287, "isPremium": false}, {"id": 2960, "title": "2960. 统计已测试设备", "slug": "/count-tested-devices-after-test-operations/", "src": "https://leetcode.cn/problems/count-tested-devices-after-test-operations/", "solution": null, "score": 1169.4209117977, "isPremium": false}, {"id": 1094, "title": "1094. 拼车", "slug": "/car-pooling/", "src": "https://leetcode.cn/problems/car-pooling/", "solution": null, "score": 1441.4290319373, "isPremium": false}, {"id": 1109, "title": "1109. 航班预订统计", "slug": "/corporate-flight-bookings/", "src": "https://leetcode.cn/problems/corporate-flight-bookings/", "solution": null, "score": 1569.7528744586, "isPremium": false}, {"id": 3355, "title": "3355. 零数组变换 I", "slug": "/zero-array-transformation-i/", "src": "https://leetcode.cn/problems/zero-array-transformation-i/", "solution": null, "score": 1591.445677589, "isPremium": false}, {"id": 56, "title": "56. 合并区间", "slug": "/merge-intervals/", "src": "https://leetcode.cn/problems/merge-intervals/", "solution": null, "score": null, "isPremium": false}, {"id": 57, "title": "57. 插入区间", "slug": "/insert-interval/", "src": "https://leetcode.cn/problems/insert-interval/", "solution": null, "score": null, "isPremium": false}, {"id": 732, "title": "732. 我的日程安排表 III", "slug": "/my-calendar-iii/", "src": "https://leetcode.cn/problems/my-calendar-iii/", "solution": null, "score": null, "isPremium": false}, {"id": 2406, "title": "2406. 将区间分为最少组数", "slug": "/divide-intervals-into-minimum-number-of-groups/", "src": "https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/", "solution": null, "score": 1713.3954468582, "isPremium": false}, {"id": 2381, "title": "2381. 字母移位 II", "slug": "/shifting-letters-ii/", "src": "https://leetcode.cn/problems/shifting-letters-ii/", "solution": null, "score": 1793.3037316825, "isPremium": false}, {"id": 3453, "title": "3453. 分割正方形 I", "slug": "/separate-squares-i/", "src": "https://leetcode.cn/problems/separate-squares-i/", "solution": null, "score": null, "isPremium": false}, {"id": 995, "title": "995. K 连续位的最小翻转次数", "slug": "/minimum-number-of-k-consecutive-bit-flips/", "src": "https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/", "solution": null, "score": 1835.4868365659, "isPremium": false}, {"id": 1589, "title": "1589. 所有排列中的最大和", "slug": "/maximum-sum-obtained-of-any-permutation/", "src": "https://leetcode.cn/problems/maximum-sum-obtained-of-any-permutation/", "solution": null, "score": 1871.3112059413, "isPremium": false}, {"id": 1526, "title": "1526. 形成目标数组的子数组最少增加次数", "slug": "/minimum-number-of-increments-on-subarrays-to-form-a-target-array/", "src": "https://leetcode.cn/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/", "solution": null, "score": 1872.0350138774, "isPremium": false}, {"id": 3356, "title": "3356. 零数组变换 II", "slug": "/zero-array-transformation-ii/", "src": "https://leetcode.cn/problems/zero-array-transformation-ii/", "solution": null, "score": 1913.4834168162, "isPremium": false}, {"id": 1943, "title": "1943. 描述绘画结果", "slug": "/describe-the-painting/", "src": "https://leetcode.cn/problems/describe-the-painting/", "solution": null, "score": 1969.2019235672, "isPremium": false}, {"id": 3224, "title": "3224. 使差值相等的最少数组改动次数", "slug": "/minimum-array-changes-to-make-differences-equal/", "src": "https://leetcode.cn/problems/minimum-array-changes-to-make-differences-equal/", "solution": null, "score": 1996.0986736442, "isPremium": false}, {"id": 2251, "title": "2251. 花期内花的数目", "slug": "/number-of-flowers-in-full-bloom/", "src": "https://leetcode.cn/problems/number-of-flowers-in-full-bloom/", "solution": null, "score": 2022.3137128296, "isPremium": false}, {"id": 2772, "title": "2772. 使数组中的所有元素都等于零", "slug": "/apply-operations-to-make-all-array-elements-equal-to-zero/", "src": "https://leetcode.cn/problems/apply-operations-to-make-all-array-elements-equal-to-zero/", "solution": null, "score": 2029.4024513478, "isPremium": false}, {"id": 3229, "title": "3229. 使数组等于目标数组所需的最少操作次数", "slug": "/minimum-operations-to-make-array-equal-to-target/", "src": "https://leetcode.cn/problems/minimum-operations-to-make-array-equal-to-target/", "solution": null, "score": 2066.5575759467, "isPremium": false}, {"id": 798, "title": "798. 得分最高的最小轮调", "slug": "/smallest-rotation-with-highest-score/", "src": "https://leetcode.cn/problems/smallest-rotation-with-highest-score/", "solution": null, "score": 2129.7051442916, "isPremium": false}, {"id": 3347, "title": "3347. 执行操作后元素的最高频率 II", "slug": "/maximum-frequency-of-an-element-after-performing-operations-ii/", "src": "https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-ii/", "solution": null, "score": 2155.599241516, "isPremium": false}, {"id": 2528, "title": "2528. 最大化城市的最小供电站数目", "slug": "/maximize-the-minimum-powered-city/", "src": "https://leetcode.cn/problems/maximize-the-minimum-powered-city/", "solution": null, "score": 2235.5784618885, "isPremium": false}, {"id": 1674, "title": "1674. 使数组互补的最少操作次数", "slug": "/minimum-moves-to-make-array-complementary/", "src": "https://leetcode.cn/problems/minimum-moves-to-make-array-complementary/", "solution": null, "score": 2333.2401505813, "isPremium": false}, {"id": 3362, "title": "3362. 零数组变换 III", "slug": "/zero-array-transformation-iii/", "src": "https://leetcode.cn/problems/zero-array-transformation-iii/", "solution": null, "score": 2423.8553548566, "isPremium": false}, {"id": 3017, "title": "3017. 按距离统计房屋对数目 II", "slug": "/count-the-number-of-houses-at-a-certain-distance-ii/", "src": "https://leetcode.cn/problems/count-the-number-of-houses-at-a-certain-distance-ii/", "solution": null, "score": 2709.4067070911, "isPremium": false}, {"id": 253, "title": "253. 会议室 II", "slug": "/meeting-rooms-ii/", "src": "https://leetcode.cn/problems/meeting-rooms-ii/", "solution": null, "score": null, "isPremium": true}, {"id": 370, "title": "370. 区间加法", "slug": "/range-addition/", "src": "https://leetcode.cn/problems/range-addition/", "solution": null, "score": null, "isPremium": true}, {"id": 1989, "title": "1989. 捉迷藏中可捕获的最大人数", "slug": "/maximum-number-of-people-that-can-be-caught-in-tag/", "src": "https://leetcode.cn/problems/maximum-number-of-people-that-can-be-caught-in-tag/", "solution": null, "score": null, "isPremium": true}, {"id": 759, "title": "759. 员工空闲时间", "slug": "/employee-free-time/", "src": "https://leetcode.cn/problems/employee-free-time/", "solution": null, "score": 1710.1120861153, "isPremium": true}, {"id": 2021, "title": "2021. 街上最亮的位置", "slug": "/brightest-position-on-street/", "src": "https://leetcode.cn/problems/brightest-position-on-street/", "solution": null, "score": null, "isPremium": true}, {"id": 2015, "title": "2015. 每段建筑物的平均高度", "slug": "/average-height-of-buildings-in-each-segment/", "src": "https://leetcode.cn/problems/average-height-of-buildings-in-each-segment/", "solution": null, "score": null, "isPremium": true}, {"id": 2237, "title": "2237. 计算街道上满足所需亮度的位置数量", "slug": "/count-positions-on-street-with-required-brightness/", "src": "https://leetcode.cn/problems/count-positions-on-street-with-required-brightness/", "solution": null, "score": null, "isPremium": true}, {"id": 3009, "title": "3009. 折线图上的最大交点数量", "slug": "/maximum-number-of-intersections-on-the-chart/", "src": "https://leetcode.cn/problems/maximum-number-of-intersections-on-the-chart/", "solution": null, "score": null, "isPremium": true}, {"id": 3279, "title": "3279. 活塞占据的最大总面积", "slug": "/maximum-total-area-occupied-by-pistons/", "src": "https://leetcode.cn/problems/maximum-total-area-occupied-by-pistons/", "solution": null, "score": null, "isPremium": true}]}, {"title": "§2.2 二维差分", "summary": "<a href=\"https://leetcode.cn/problems/stamping-the-grid/solution/wu-nao-zuo-fa-er-wei-qian-zhui-he-er-wei-zwiu/\">【图解】从一维差分到二维差分</a><br>", "isLeaf": true, "children": [], "problems": [{"id": 2536, "title": "2536. 子矩阵元素加 1", "slug": "/increment-submatrices-by-one/", "src": "https://leetcode.cn/problems/increment-submatrices-by-one/", "solution": null, "score": 1583.3117784523, "isPremium": false}, {"id": 850, "title": "850. 矩形面积 II", "slug": "/rectangle-area-ii/", "src": "https://leetcode.cn/problems/rectangle-area-ii/", "solution": null, "score": 2235.9672341699, "isPremium": false}, {"id": 2132, "title": "2132. 用邮票贴满网格图", "slug": "/stamping-the-grid/", "src": "https://leetcode.cn/problems/stamping-the-grid/", "solution": null, "score": 2364.3930657709, "isPremium": false}, {"id": "LCP 74", "title": "LCP 74. 最强祝福力场", "slug": "/xepqZ5/", "src": "https://leetcode.cn/problems/xepqZ5/", "solution": null, "score": null, "isPremium": false}]}], "problems": []}, {"title": "三、栈", "summary": "", "isLeaf": false, "children": [{"title": "§3.1 基础", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 1441, "title": "1441. 用栈操作构建数组", "slug": "/build-an-array-with-stack-operations/", "src": "https://leetcode.cn/problems/build-an-array-with-stack-operations/", "solution": null, "score": 1180.3543157775, "isPremium": false}, {"id": 844, "title": "844. 比较含退格的字符串", "slug": "/backspace-string-compare/", "src": "https://leetcode.cn/problems/backspace-string-compare/", "solution": null, "score": 1227.7906887239, "isPremium": false}, {"id": 682, "title": "682. 棒球比赛", "slug": "/baseball-game/", "src": "https://leetcode.cn/problems/baseball-game/", "solution": null, "score": null, "isPremium": false}, {"id": 2390, "title": "2390. 从字符串中移除星号", "slug": "/removing-stars-from-a-string/", "src": "https://leetcode.cn/problems/removing-stars-from-a-string/", "solution": null, "score": 1347.8521638635, "isPremium": false}, {"id": 1472, "title": "1472. 设计浏览器历史记录", "slug": "/design-browser-history/", "src": "https://leetcode.cn/problems/design-browser-history/", "solution": null, "score": 1453.7818053022, "isPremium": false}, {"id": 946, "title": "946. 验证栈序列", "slug": "/validate-stack-sequences/", "src": "https://leetcode.cn/problems/validate-stack-sequences/", "solution": null, "score": 1461.9157715206, "isPremium": false}, {"id": 3412, "title": "3412. 计算字符串的镜像分数", "slug": "/find-mirror-score-of-a-string/", "src": "https://leetcode.cn/problems/find-mirror-score-of-a-string/", "solution": null, "score": 1578.4458037997, "isPremium": false}, {"id": 71, "title": "71. 简化路径", "slug": "/simplify-path/", "src": "https://leetcode.cn/problems/simplify-path/", "solution": null, "score": null, "isPremium": false}]}, {"title": "§3.2 进阶", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 3170, "title": "3170. 删除星号以后字典序最小的字符串", "slug": "/lexicographically-minimum-string-after-removing-stars/", "src": "https://leetcode.cn/problems/lexicographically-minimum-string-after-removing-stars/", "solution": null, "score": 1772.4702293335, "isPremium": false}, {"id": 155, "title": "155. 最小栈", "slug": "/min-stack/", "src": "https://leetcode.cn/problems/min-stack/", "solution": null, "score": null, "isPremium": false}, {"id": 1381, "title": "1381. 设计一个支持增量操作的栈", "slug": "/design-a-stack-with-increment-operation/", "src": "https://leetcode.cn/problems/design-a-stack-with-increment-operation/", "solution": null, "score": 1285.9726675488, "isPremium": false}, {"id": 636, "title": "636. 函数的独占时间", "slug": "/exclusive-time-of-functions/", "src": "https://leetcode.cn/problems/exclusive-time-of-functions/", "solution": null, "score": null, "isPremium": false}, {"id": 2434, "title": "2434. 使用机器人打印字典序最小的字符串", "slug": "/using-a-robot-to-print-the-lexicographically-smallest-string/", "src": "https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/", "solution": null, "score": 1953.137726744, "isPremium": false}, {"id": 895, "title": "895. 最大频率栈", "slug": "/maximum-frequency-stack/", "src": "https://leetcode.cn/problems/maximum-frequency-stack/", "solution": null, "score": 2027.8772739639, "isPremium": false}, {"id": 1172, "title": "1172. 餐盘栈", "slug": "/dinner-plate-stacks/", "src": "https://leetcode.cn/problems/dinner-plate-stacks/", "solution": null, "score": 2109.9830154953, "isPremium": false}, {"id": 2589, "title": "2589. 完成所有任务的最少时间", "slug": "/minimum-time-to-complete-all-tasks/", "src": "https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/", "solution": null, "score": 2380.5983169295, "isPremium": false}, {"id": 716, "title": "716. 最大栈", "slug": "/max-stack/", "src": "https://leetcode.cn/problems/max-stack/", "solution": null, "score": null, "isPremium": true}]}, {"title": "§3.3 邻项消除", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 2696, "title": "2696. 删除子串后的字符串最小长度", "slug": "/minimum-string-length-after-removing-substrings/", "src": "https://leetcode.cn/problems/minimum-string-length-after-removing-substrings/", "solution": null, "score": 1282.3870247003, "isPremium": false}, {"id": 1047, "title": "1047. 删除字符串中的所有相邻重复项", "slug": "/remove-all-adjacent-duplicates-in-string/", "src": "https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/", "solution": null, "score": 1286.3167937403, "isPremium": false}, {"id": 1544, "title": "1544. 整理字符串", "slug": "/make-the-string-great/", "src": "https://leetcode.cn/problems/make-the-string-great/", "solution": null, "score": 1344.226133202, "isPremium": false}, {"id": 1003, "title": "1003. 检查替换后的词是否有效", "slug": "/check-if-word-is-valid-after-substitutions/", "src": "https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions/", "solution": null, "score": 1426.7144554733, "isPremium": false}, {"id": 2216, "title": "2216. 美化数组的最少删除数", "slug": "/minimum-deletions-to-make-array-beautiful/", "src": "https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful/", "solution": null, "score": 1509.5562928491, "isPremium": false}, {"id": 1209, "title": "1209. 删除字符串中的所有相邻重复项 II", "slug": "/remove-all-adjacent-duplicates-in-string-ii/", "src": "https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/", "solution": null, "score": 1541.5405749918, "isPremium": false}, {"id": 2211, "title": "2211. 统计道路上的碰撞次数", "slug": "/count-collisions-on-a-road/", "src": "https://leetcode.cn/problems/count-collisions-on-a-road/", "solution": null, "score": 1581.4963716166, "isPremium": false}, {"id": 735, "title": "735. 小行星碰撞", "slug": "/asteroid-collision/", "src": "https://leetcode.cn/problems/asteroid-collision/", "solution": null, "score": null, "isPremium": false}, {"id": 1717, "title": "1717. 删除子字符串的最大得分", "slug": "/maximum-score-from-removing-substrings/", "src": "https://leetcode.cn/problems/maximum-score-from-removing-substrings/", "solution": null, "score": 1867.9916069568, "isPremium": false}, {"id": 2197, "title": "2197. 替换数组中的非互质数", "slug": "/replace-non-coprime-numbers-in-array/", "src": "https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/", "solution": null, "score": 2057.4788263111, "isPremium": false}, {"id": 2751, "title": "2751. 机器人碰撞", "slug": "/robot-collisions/", "src": "https://leetcode.cn/problems/robot-collisions/", "solution": null, "score": 2091.6474629767, "isPremium": false}]}, {"title": "§3.4 合法括号字符串", "summary": "注：部分题目可以不用栈，而是用一个数字记录嵌套深度。<br>", "isLeaf": true, "children": [], "problems": [{"id": 20, "title": "20. 有效的括号", "slug": "/valid-parentheses/", "src": "https://leetcode.cn/problems/valid-parentheses/", "solution": null, "score": null, "isPremium": false}, {"id": 921, "title": "921. 使括号有效的最少添加", "slug": "/minimum-add-to-make-parentheses-valid/", "src": "https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/", "solution": null, "score": 1242.4710735813, "isPremium": false}, {"id": 1021, "title": "1021. 删除最外层的括号", "slug": "/remove-outermost-parentheses/", "src": "https://leetcode.cn/problems/remove-outermost-parentheses/", "solution": null, "score": 1311.3495317884, "isPremium": false}, {"id": 1614, "title": "1614. 括号的最大嵌套深度", "slug": "/maximum-nesting-depth-of-the-parentheses/", "src": "https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/", "solution": null, "score": 1322.8302750313, "isPremium": false}, {"id": 1190, "title": "1190. 反转每对括号间的子串", "slug": "/reverse-substrings-between-each-pair-of-parentheses/", "src": "https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/", "solution": null, "score": 1485.6550472186, "isPremium": false}, {"id": 856, "title": "856. 括号的分数", "slug": "/score-of-parentheses/", "src": "https://leetcode.cn/problems/score-of-parentheses/", "solution": null, "score": 1562.7212466716, "isPremium": false}, {"id": 1249, "title": "1249. 移除无效的括号", "slug": "/minimum-remove-to-make-valid-parentheses/", "src": "https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/", "solution": null, "score": 1657.1231739081, "isPremium": false}, {"id": 1963, "title": "1963. 使字符串平衡的最小交换次数", "slug": "/minimum-number-of-swaps-to-make-the-string-balanced/", "src": "https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-string-balanced/", "solution": null, "score": 1688.9209684568, "isPremium": false}, {"id": 678, "title": "678. 有效的括号字符串", "slug": "/valid-parenthesis-string/", "src": "https://leetcode.cn/problems/valid-parenthesis-string/", "solution": null, "score": null, "isPremium": false}, {"id": 1111, "title": "1111. 有效括号的嵌套深度", "slug": "/maximum-nesting-depth-of-two-valid-parentheses-strings/", "src": "https://leetcode.cn/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/", "solution": null, "score": 1749.4981778209, "isPremium": false}, {"id": 1541, "title": "1541. 平衡括号字符串的最少插入次数", "slug": "/minimum-insertions-to-balance-a-parentheses-string/", "src": "https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/", "solution": null, "score": 1759.0197295594, "isPremium": false}, {"id": 2116, "title": "2116. 判断一个括号字符串是否有效", "slug": "/check-if-a-parentheses-string-can-be-valid/", "src": "https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid/", "solution": null, "score": 2037.6527962599, "isPremium": false}, {"id": 32, "title": "32. 最长有效括号", "slug": "/longest-valid-parentheses/", "src": "https://leetcode.cn/problems/longest-valid-parentheses/", "solution": null, "score": null, "isPremium": false}]}, {"title": "§3.5 表达式解析", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 150, "title": "150. 逆波兰表达式求值", "slug": "/evaluate-reverse-polish-notation/", "src": "https://leetcode.cn/problems/evaluate-reverse-polish-notation/", "solution": null, "score": null, "isPremium": false}, {"id": 1006, "title": "1006. 笨阶乘", "slug": "/clumsy-factorial/", "src": "https://leetcode.cn/problems/clumsy-factorial/", "solution": null, "score": 1407.9870845299, "isPremium": false}, {"id": 224, "title": "224. 基本计算器", "slug": "/basic-calculator/", "src": "https://leetcode.cn/problems/basic-calculator/", "solution": null, "score": null, "isPremium": false}, {"id": 227, "title": "227. 基本计算器 II", "slug": "/basic-calculator-ii/", "src": "https://leetcode.cn/problems/basic-calculator-ii/", "solution": null, "score": null, "isPremium": false}, {"id": 726, "title": "726. 原子的数量", "slug": "/number-of-atoms/", "src": "https://leetcode.cn/problems/number-of-atoms/", "solution": null, "score": null, "isPremium": false}, {"id": 1106, "title": "1106. 解析布尔表达式", "slug": "/parsing-a-boolean-expression/", "src": "https://leetcode.cn/problems/parsing-a-boolean-expression/", "solution": null, "score": 1880.4226853663, "isPremium": false}, {"id": 591, "title": "591. 标签验证器", "slug": "/tag-validator/", "src": "https://leetcode.cn/problems/tag-validator/", "solution": null, "score": null, "isPremium": false}, {"id": 736, "title": "736. Lisp 语法解析", "slug": "/parse-lisp-expression/", "src": "https://leetcode.cn/problems/parse-lisp-expression/", "solution": null, "score": null, "isPremium": false}, {"id": 1096, "title": "1096. 花括号展开 II", "slug": "/brace-expansion-ii/", "src": "https://leetcode.cn/problems/brace-expansion-ii/", "solution": null, "score": 2348.5159376523, "isPremium": false}, {"id": 1896, "title": "1896. 反转表达式值的最少操作次数", "slug": "/minimum-cost-to-change-the-final-value-of-expression/", "src": "https://leetcode.cn/problems/minimum-cost-to-change-the-final-value-of-expression/", "solution": null, "score": 2531.6452775023, "isPremium": false}, {"id": 770, "title": "770. 基本计算器 IV", "slug": "/basic-calculator-iv/", "src": "https://leetcode.cn/problems/basic-calculator-iv/", "solution": null, "score": 2863.1378294349, "isPremium": false}, {"id": 439, "title": "439. 三元表达式解析器", "slug": "/ternary-expression-parser/", "src": "https://leetcode.cn/problems/ternary-expression-parser/", "solution": null, "score": null, "isPremium": true}, {"id": 772, "title": "772. 基本计算器 III", "slug": "/basic-calculator-iii/", "src": "https://leetcode.cn/problems/basic-calculator-iii/", "solution": null, "score": null, "isPremium": true}, {"id": 1087, "title": "1087. 花括号展开", "slug": "/brace-expansion/", "src": "https://leetcode.cn/problems/brace-expansion/", "solution": null, "score": 1480.1116248664, "isPremium": true}, {"id": 1597, "title": "1597. 根据中缀表达式构造二叉表达式树", "slug": "/build-binary-expression-tree-from-infix-expression/", "src": "https://leetcode.cn/problems/build-binary-expression-tree-from-infix-expression/", "solution": null, "score": null, "isPremium": true}, {"id": 1628, "title": "1628. 设计带解析函数的表达式树", "slug": "/design-an-expression-tree-with-evaluate-function/", "src": "https://leetcode.cn/problems/design-an-expression-tree-with-evaluate-function/", "solution": null, "score": null, "isPremium": true}]}, {"title": "§3.6 对顶栈", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 2296, "title": "2296. 设计一个文本编辑器", "slug": "/design-a-text-editor/", "src": "https://leetcode.cn/problems/design-a-text-editor/", "solution": null, "score": 1911.8282317986, "isPremium": false}]}, {"title": "§3.7 单调栈", "summary": "见 <a href=\"/lc-rating/list/monotonic_stack\">单调栈题单</a>。<br>", "isLeaf": false, "children": [], "problems": []}], "problems": []}, {"title": "四、队列", "summary": "队列常用在 BFS 中，见 <a href=\"/lc-rating/list/grid\">网格图题单</a> 和 <a href=\"/lc-rating/list/graph\">图论题单</a>。与此相比，栈常用在 DFS 中，但无需我们手动维护。<br>", "isLeaf": false, "children": [{"title": "§4.1 基础", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 933, "title": "933. 最近的请求次数", "slug": "/number-of-recent-calls/", "src": "https://leetcode.cn/problems/number-of-recent-calls/", "solution": null, "score": 1337.8472367494, "isPremium": false}, {"id": 950, "title": "950. 按递增顺序显示卡牌", "slug": "/reveal-cards-in-increasing-order/", "src": "https://leetcode.cn/problems/reveal-cards-in-increasing-order/", "solution": null, "score": 1686.4493679523, "isPremium": false}, {"id": 649, "title": "649. Dota2 参议院", "slug": "/dota2-senate/", "src": "https://leetcode.cn/problems/dota2-senate/", "solution": null, "score": null, "isPremium": false}, {"id": 346, "title": "346. 数据流中的移动平均值", "slug": "/moving-average-from-data-stream/", "src": "https://leetcode.cn/problems/moving-average-from-data-stream/", "solution": null, "score": null, "isPremium": true}, {"id": 362, "title": "362. 敲击计数器", "slug": "/design-hit-counter/", "src": "https://leetcode.cn/problems/design-hit-counter/", "solution": null, "score": null, "isPremium": true}, {"id": 379, "title": "379. 电话目录管理系统", "slug": "/design-phone-directory/", "src": "https://leetcode.cn/problems/design-phone-directory/", "solution": null, "score": null, "isPremium": true}, {"id": 1429, "title": "1429. 第一个唯一数字", "slug": "/first-unique-number/", "src": "https://leetcode.cn/problems/first-unique-number/", "solution": null, "score": null, "isPremium": true}, {"id": 2534, "title": "2534. 通过门的时间", "slug": "/time-taken-to-cross-the-door/", "src": "https://leetcode.cn/problems/time-taken-to-cross-the-door/", "solution": null, "score": null, "isPremium": true}]}, {"title": "§4.2 设计", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 225, "title": "225. 用队列实现栈", "slug": "/implement-stack-using-queues/", "src": "https://leetcode.cn/problems/implement-stack-using-queues/", "solution": null, "score": null, "isPremium": false}, {"id": 232, "title": "232. 用栈实现队列", "slug": "/implement-queue-using-stacks/", "src": "https://leetcode.cn/problems/implement-queue-using-stacks/", "solution": null, "score": null, "isPremium": false}, {"id": 622, "title": "622. 设计循环队列", "slug": "/design-circular-queue/", "src": "https://leetcode.cn/problems/design-circular-queue/", "solution": null, "score": null, "isPremium": false}, {"id": 641, "title": "641. 设计循环双端队列", "slug": "/design-circular-deque/", "src": "https://leetcode.cn/problems/design-circular-deque/", "solution": null, "score": null, "isPremium": false}, {"id": 1670, "title": "1670. 设计前中后队列", "slug": "/design-front-middle-back-queue/", "src": "https://leetcode.cn/problems/design-front-middle-back-queue/", "solution": null, "score": 1610.1866391145, "isPremium": false}]}, {"title": "§4.3 双端队列", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 2810, "title": "2810. 故障键盘", "slug": "/faulty-keyboard/", "src": "https://leetcode.cn/problems/faulty-keyboard/", "solution": null, "score": 1192.9770230345, "isPremium": false}]}, {"title": "§4.4 单调队列", "summary": "个人觉得叫**单调双端队列**更准确。<br><a href=\"https://www.bilibili.com/video/BV1bM411X72E/\">原理讲解</a><br>", "isLeaf": true, "children": [], "problems": [{"id": 239, "title": "239. 滑动窗口最大值", "slug": "/sliding-window-maximum/", "src": "https://leetcode.cn/problems/sliding-window-maximum/", "solution": null, "score": null, "isPremium": false}, {"id": "LCR 184", "title": "LCR 184. 设计自助结算系统", "slug": "/dui-lie-de-zui-da-zhi-lcof/", "src": "https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/", "solution": null, "score": null, "isPremium": false}, {"id": 1438, "title": "1438. 绝对差不超过限制的最长连续子数组", "slug": "/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/", "src": "https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/", "solution": null, "score": 1672.1678031263, "isPremium": false}, {"id": 2762, "title": "2762. 不间断子数组", "slug": "/continuous-subarrays/", "src": "https://leetcode.cn/problems/continuous-subarrays/", "solution": null, "score": 1940.2116985812, "isPremium": false}, {"id": 2398, "title": "2398. 预算内的最多机器人数目", "slug": "/maximum-number-of-robots-within-budget/", "src": "https://leetcode.cn/problems/maximum-number-of-robots-within-budget/", "solution": null, "score": 1917.2145829853, "isPremium": false}, {"id": 862, "title": "862. 和至少为 K 的最短子数组", "slug": "/shortest-subarray-with-sum-at-least-k/", "src": "https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/", "solution": null, "score": 2306.8472649456, "isPremium": false}, {"id": 1499, "title": "1499. 满足不等式的最大值", "slug": "/max-value-of-equation/", "src": "https://leetcode.cn/problems/max-value-of-equation/", "solution": null, "score": 2456.3900212097, "isPremium": false}, {"id": 2071, "title": "2071. 你可以安排的最多任务数目", "slug": "/maximum-number-of-tasks-you-can-assign/", "src": "https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/", "solution": null, "score": 2648.1748409542, "isPremium": false}]}, {"title": "§4.5 单调队列优化 DP", "summary": "一般用来维护一段转移来源的最值。<br>1. 前提：区间右端点变大时，左端点也在变大（同滑动窗口）。<br>2. 转移前，去掉队首无用数据。<br>3. 计算转移（直接从队首转移）。<br>4. 把数据（一般是 $f[i]$）插入队尾前，去掉队尾无用数据。<br>", "isLeaf": true, "children": [], "problems": [{"id": 2944, "title": "2944. 购买水果需要的最少金币数", "slug": "/minimum-number-of-coins-for-fruits/", "src": "https://leetcode.cn/problems/minimum-number-of-coins-for-fruits/", "solution": null, "score": 1708.9663754668, "isPremium": false}, {"id": 1696, "title": "1696. 跳跃游戏 VI", "slug": "/jump-game-vi/", "src": "https://leetcode.cn/problems/jump-game-vi/", "solution": null, "score": 1954.2533254344, "isPremium": false}, {"id": 1425, "title": "1425. 带限制的子序列和", "slug": "/constrained-subsequence-sum/", "src": "https://leetcode.cn/problems/constrained-subsequence-sum/", "solution": null, "score": 2032.4773038683, "isPremium": false}, {"id": 375, "title": "375. 猜数字大小 II", "slug": "/guess-number-higher-or-lower-ii/", "src": "https://leetcode.cn/problems/guess-number-higher-or-lower-ii/", "solution": null, "score": null, "isPremium": false}, {"id": 1687, "title": "1687. 从仓库到码头运输箱子", "slug": "/delivering-boxes-from-storage-to-ports/", "src": "https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/", "solution": null, "score": 2610.0826855063, "isPremium": false}, {"id": 3117, "title": "3117. 划分数组得到最小的值之和", "slug": "/minimum-sum-of-values-by-dividing-array/", "src": "https://leetcode.cn/problems/minimum-sum-of-values-by-dividing-array/", "solution": null, "score": 2735.0909781144, "isPremium": false}, {"id": 2945, "title": "2945. 找到最大非递减数组的长度", "slug": "/find-maximum-non-decreasing-array-length/", "src": "https://leetcode.cn/problems/find-maximum-non-decreasing-array-length/", "solution": null, "score": 2943.2173551759, "isPremium": false}, {"id": 2969, "title": "2969. 购买水果需要的最少金币数 II", "slug": "/minimum-number-of-coins-for-fruits-ii/", "src": "https://leetcode.cn/problems/minimum-number-of-coins-for-fruits-ii/", "solution": null, "score": null, "isPremium": true}]}], "problems": []}, {"title": "五、堆（优先队列）", "summary": "", "isLeaf": false, "children": [{"title": "§5.1 基础", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 1046, "title": "1046. 最后一块石头的重量", "slug": "/last-stone-weight/", "src": "https://leetcode.cn/problems/last-stone-weight/", "solution": null, "score": 1172.6819789183, "isPremium": false}, {"id": 3264, "title": "3264. K 次乘运算后的最终数组 I", "slug": "/final-array-state-after-k-multiplication-operations-i/", "src": "https://leetcode.cn/problems/final-array-state-after-k-multiplication-operations-i/", "solution": null, "score": 1177.5447304844, "isPremium": false}, {"id": 2558, "title": "2558. 从数量最多的堆取走礼物", "slug": "/take-gifts-from-the-richest-pile/", "src": "https://leetcode.cn/problems/take-gifts-from-the-richest-pile/", "solution": null, "score": 1276.7817742915, "isPremium": false}, {"id": 2336, "title": "2336. 无限集中的最小数字", "slug": "/smallest-number-in-infinite-set/", "src": "https://leetcode.cn/problems/smallest-number-in-infinite-set/", "solution": null, "score": 1375.0376362104, "isPremium": false}, {"id": 2530, "title": "2530. 执行 K 次操作后的最大分数", "slug": "/maximal-score-after-applying-k-operations/", "src": "https://leetcode.cn/problems/maximal-score-after-applying-k-operations/", "solution": null, "score": 1386.1200017827, "isPremium": false}, {"id": 3066, "title": "3066. 超过阈值的最少操作数 II", "slug": "/minimum-operations-to-exceed-threshold-value-ii/", "src": "https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-ii/", "solution": null, "score": 1399.5303229631, "isPremium": false}, {"id": 1962, "title": "1962. 移除石子使总数最小", "slug": "/remove-stones-to-minimize-the-total/", "src": "https://leetcode.cn/problems/remove-stones-to-minimize-the-total/", "solution": null, "score": 1418.6847740057, "isPremium": false}, {"id": 703, "title": "703. 数据流中的第 K 大元素", "slug": "/kth-largest-element-in-a-stream/", "src": "https://leetcode.cn/problems/kth-largest-element-in-a-stream/", "solution": null, "score": null, "isPremium": false}, {"id": 3275, "title": "3275. 第 K 近障碍物查询", "slug": "/k-th-nearest-obstacle-queries/", "src": "https://leetcode.cn/problems/k-th-nearest-obstacle-queries/", "solution": null, "score": 1419.6326908404, "isPremium": false}, {"id": 1845, "title": "1845. 座位预约管理系统", "slug": "/seat-reservation-manager/", "src": "https://leetcode.cn/problems/seat-reservation-manager/", "solution": null, "score": 1428.6729861424, "isPremium": false}, {"id": 2208, "title": "2208. 将数组和减半的最少操作次数", "slug": "/minimum-operations-to-halve-array-sum/", "src": "https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/", "solution": null, "score": 1550.0978082682, "isPremium": false}, {"id": 2233, "title": "2233. K 次增加后的最大乘积", "slug": "/maximum-product-after-k-increments/", "src": "https://leetcode.cn/problems/maximum-product-after-k-increments/", "solution": null, "score": 1685.5389350949, "isPremium": false}, {"id": 3296, "title": "3296. 移山所需的最少秒数", "slug": "/minimum-number-of-seconds-to-make-mountain-height-zero/", "src": "https://leetcode.cn/problems/minimum-number-of-seconds-to-make-mountain-height-zero/", "solution": null, "score": 1694.7320914942, "isPremium": false}, {"id": 1942, "title": "1942. 最小未被占据椅子的编号", "slug": "/the-number-of-the-smallest-unoccupied-chair/", "src": "https://leetcode.cn/problems/the-number-of-the-smallest-unoccupied-chair/", "solution": null, "score": 1695.2832486322, "isPremium": false}, {"id": 1801, "title": "1801. 积压订单中的订单总数", "slug": "/number-of-orders-in-the-backlog/", "src": "https://leetcode.cn/problems/number-of-orders-in-the-backlog/", "solution": null, "score": 1711.1205064321, "isPremium": false}, {"id": 2406, "title": "2406. 将区间分为最少组数", "slug": "/divide-intervals-into-minimum-number-of-groups/", "src": "https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/", "solution": null, "score": 1713.3954468582, "isPremium": false}, {"id": 2462, "title": "2462. 雇佣 K 位工人的总代价", "slug": "/total-cost-to-hire-k-workers/", "src": "https://leetcode.cn/problems/total-cost-to-hire-k-workers/", "solution": null, "score": 1763.6404758359, "isPremium": false}, {"id": 1834, "title": "1834. 单线程 CPU", "slug": "/single-threaded-cpu/", "src": "https://leetcode.cn/problems/single-threaded-cpu/", "solution": null, "score": 1797.7466000366, "isPremium": false}, {"id": 3478, "title": "3478. 选出和最大的 K 个元素", "slug": "/choose-k-elements-with-maximum-sum/", "src": "https://leetcode.cn/problems/choose-k-elements-with-maximum-sum/", "solution": null, "score": null, "isPremium": false}, {"id": 3408, "title": "3408. 设计任务管理器", "slug": "/design-task-manager/", "src": "https://leetcode.cn/problems/design-task-manager/", "solution": null, "score": 1806.5135130091, "isPremium": false}, {"id": 1792, "title": "1792. 最大平均通过率", "slug": "/maximum-average-pass-ratio/", "src": "https://leetcode.cn/problems/maximum-average-pass-ratio/", "solution": null, "score": 1817.9978644712, "isPremium": false}, {"id": 2931, "title": "2931. 购买物品的最大开销", "slug": "/maximum-spending-after-buying-items/", "src": "https://leetcode.cn/problems/maximum-spending-after-buying-items/", "solution": null, "score": 1822.3170524016, "isPremium": false}, {"id": 1882, "title": "1882. 使用服务器处理任务", "slug": "/process-tasks-using-servers/", "src": "https://leetcode.cn/problems/process-tasks-using-servers/", "solution": null, "score": 1979.1112273597, "isPremium": false}, {"id": 2402, "title": "2402. 会议室 III", "slug": "/meeting-rooms-iii/", "src": "https://leetcode.cn/problems/meeting-rooms-iii/", "solution": null, "score": 2092.8943149547, "isPremium": false}, {"id": 253, "title": "253. 会议室 II", "slug": "/meeting-rooms-ii/", "src": "https://leetcode.cn/problems/meeting-rooms-ii/", "solution": null, "score": null, "isPremium": true}, {"id": 1167, "title": "1167. 连接木棍的最低费用", "slug": "/minimum-cost-to-connect-sticks/", "src": "https://leetcode.cn/problems/minimum-cost-to-connect-sticks/", "solution": null, "score": 1481.5701319876, "isPremium": true}]}, {"title": "§5.2 进阶", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 23, "title": "23. 合并 K 个升序链表", "slug": "/merge-k-sorted-lists/", "src": "https://leetcode.cn/problems/merge-k-sorted-lists/", "solution": null, "score": null, "isPremium": false}, {"id": 355, "title": "355. 设计推特", "slug": "/design-twitter/", "src": "https://leetcode.cn/problems/design-twitter/", "solution": null, "score": null, "isPremium": false}, {"id": 502, "title": "502. IPO", "slug": "/ipo/", "src": "https://leetcode.cn/problems/ipo/", "solution": null, "score": null, "isPremium": false}, {"id": 1705, "title": "1705. 吃苹果的最大数目", "slug": "/maximum-number-of-eaten-apples/", "src": "https://leetcode.cn/problems/maximum-number-of-eaten-apples/", "solution": null, "score": 1929.9086934334, "isPremium": false}, {"id": 778, "title": "778. 水位上升的泳池中游泳", "slug": "/swim-in-rising-water/", "src": "https://leetcode.cn/problems/swim-in-rising-water/", "solution": null, "score": 2096.6201393558, "isPremium": false}, {"id": 1631, "title": "1631. 最小体力消耗路径", "slug": "/path-with-minimum-effort/", "src": "https://leetcode.cn/problems/path-with-minimum-effort/", "solution": null, "score": 1947.5013967785, "isPremium": false}, {"id": 1354, "title": "1354. 多次求和构造目标数组", "slug": "/construct-target-array-with-multiple-sums/", "src": "https://leetcode.cn/problems/construct-target-array-with-multiple-sums/", "solution": null, "score": 2014.7655493665, "isPremium": false}, {"id": 1353, "title": "1353. 最多可以参加的会议数目", "slug": "/maximum-number-of-events-that-can-be-attended/", "src": "https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/", "solution": null, "score": 2015.7291888336, "isPremium": false}, {"id": 1235, "title": "1235. 规划兼职工作", "slug": "/maximum-profit-in-job-scheduling/", "src": "https://leetcode.cn/problems/maximum-profit-in-job-scheduling/", "solution": null, "score": 2022.8520613737, "isPremium": false}, {"id": 632, "title": "632. 最小区间", "slug": "/smallest-range-covering-elements-from-k-lists/", "src": "https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/", "solution": null, "score": null, "isPremium": false}, {"id": 2542, "title": "2542. 最大子序列的分数", "slug": "/maximum-subsequence-score/", "src": "https://leetcode.cn/problems/maximum-subsequence-score/", "solution": null, "score": 2056.2598215101, "isPremium": false}, {"id": 1383, "title": "1383. 最大的团队表现值", "slug": "/maximum-performance-of-a-team/", "src": "https://leetcode.cn/problems/maximum-performance-of-a-team/", "solution": null, "score": 2091.3820373571, "isPremium": false}, {"id": 2503, "title": "2503. 矩阵查询可获得的最大分数", "slug": "/maximum-number-of-points-from-grid-queries/", "src": "https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/", "solution": null, "score": 2195.6540241654, "isPremium": false}, {"id": 2163, "title": "2163. 删除元素后和的最小差值", "slug": "/minimum-difference-in-sums-after-removal-of-elements/", "src": "https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/", "solution": null, "score": 2225.3877535768, "isPremium": false}, {"id": 857, "title": "857. 雇佣 K 名工人的最低成本", "slug": "/minimum-cost-to-hire-k-workers/", "src": "https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/", "solution": null, "score": 2259.6572191969, "isPremium": false}, {"id": 1606, "title": "1606. 找到处理最多请求的服务器", "slug": "/find-servers-that-handled-most-number-of-requests/", "src": "https://leetcode.cn/problems/find-servers-that-handled-most-number-of-requests/", "solution": null, "score": 2275.7337818748, "isPremium": false}, {"id": 1851, "title": "1851. 包含每个查询的最小区间", "slug": "/minimum-interval-to-include-each-query/", "src": "https://leetcode.cn/problems/minimum-interval-to-include-each-query/", "solution": null, "score": 2286.1378742318, "isPremium": false}, {"id": 218, "title": "218. 天际线问题", "slug": "/the-skyline-problem/", "src": "https://leetcode.cn/problems/the-skyline-problem/", "solution": null, "score": null, "isPremium": false}, {"id": 407, "title": "407. 接雨水 II", "slug": "/trapping-rain-water-ii/", "src": "https://leetcode.cn/problems/trapping-rain-water-ii/", "solution": null, "score": null, "isPremium": false}, {"id": 2940, "title": "2940. 找到 Alice 和 Bob 可以相遇的建筑", "slug": "/find-building-where-alice-and-bob-can-meet/", "src": "https://leetcode.cn/problems/find-building-where-alice-and-bob-can-meet/", "solution": null, "score": 2327.4743300299, "isPremium": false}, {"id": 3399, "title": "3399. 字符相同的最短子字符串 II", "slug": "/smallest-substring-with-identical-characters-ii/", "src": "https://leetcode.cn/problems/smallest-substring-with-identical-characters-ii/", "solution": null, "score": 2375.9062896615, "isPremium": false}, {"id": 2589, "title": "2589. 完成所有任务的最少时间", "slug": "/minimum-time-to-complete-all-tasks/", "src": "https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/", "solution": null, "score": 2380.5983169295, "isPremium": false}, {"id": 3266, "title": "3266. K 次乘运算后的最终数组 II", "slug": "/final-array-state-after-k-multiplication-operations-ii/", "src": "https://leetcode.cn/problems/final-array-state-after-k-multiplication-operations-ii/", "solution": null, "score": 2508.6766880695, "isPremium": false}, {"id": 1675, "title": "1675. 数组的最小偏移量", "slug": "/minimize-deviation-in-array/", "src": "https://leetcode.cn/problems/minimize-deviation-in-array/", "solution": null, "score": 2533.3027905062, "isPremium": false}, {"id": 2617, "title": "2617. 网格图中最少访问的格子数", "slug": "/minimum-number-of-visited-cells-in-a-grid/", "src": "https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/", "solution": null, "score": 2581.9961985753, "isPremium": false}, {"id": 2532, "title": "2532. 过桥的时间", "slug": "/time-to-cross-a-bridge/", "src": "https://leetcode.cn/problems/time-to-cross-a-bridge/", "solution": null, "score": 2588.8752130913, "isPremium": false}, {"id": "LCP 33", "title": "LCP 33. 蓄水", "slug": "/o8SXZn/", "src": "https://leetcode.cn/problems/o8SXZn/", "solution": null, "score": null, "isPremium": false}, {"id": 1199, "title": "1199. 建造街区的最短时间", "slug": "/minimum-time-to-build-blocks/", "src": "https://leetcode.cn/problems/minimum-time-to-build-blocks/", "solution": null, "score": 2250.2578740769, "isPremium": true}]}, {"title": "§5.3 重排元素", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 984, "title": "984. 不含 AAA 或 BBB 的字符串", "slug": "/string-without-aaa-or-bbb/", "src": "https://leetcode.cn/problems/string-without-aaa-or-bbb/", "solution": null, "score": 1474.0150725665, "isPremium": false}, {"id": 767, "title": "767. 重构字符串", "slug": "/reorganize-string/", "src": "https://leetcode.cn/problems/reorganize-string/", "solution": null, "score": 1681.3263732456, "isPremium": false}, {"id": 1054, "title": "1054. 距离相等的条形码", "slug": "/distant-barcodes/", "src": "https://leetcode.cn/problems/distant-barcodes/", "solution": null, "score": 1701.5735371897, "isPremium": false}, {"id": 1953, "title": "1953. 你可以工作的最大周数", "slug": "/maximum-number-of-weeks-for-which-you-can-work/", "src": "https://leetcode.cn/problems/maximum-number-of-weeks-for-which-you-can-work/", "solution": null, "score": 1803.7518552874, "isPremium": false}, {"id": 1405, "title": "1405. 最长快乐字符串", "slug": "/longest-happy-string/", "src": "https://leetcode.cn/problems/longest-happy-string/", "solution": null, "score": 1820.58557644, "isPremium": false}, {"id": 3081, "title": "3081. 替换字符串中的问号使分数最小", "slug": "/replace-question-marks-in-string-to-minimize-its-value/", "src": "https://leetcode.cn/problems/replace-question-marks-in-string-to-minimize-its-value/", "solution": null, "score": 1904.6714229335, "isPremium": false}, {"id": 621, "title": "621. 任务调度器", "slug": "/task-scheduler/", "src": "https://leetcode.cn/problems/task-scheduler/", "solution": null, "score": null, "isPremium": false}, {"id": 358, "title": "358. K 距离间隔重排字符串", "slug": "/rearrange-string-k-distance-apart/", "src": "https://leetcode.cn/problems/rearrange-string-k-distance-apart/", "solution": null, "score": null, "isPremium": true}]}, {"title": "§5.4 第 K 小/大", "summary": "部分题目也可以用二分解决。<br>", "isLeaf": true, "children": [], "problems": [{"id": 264, "title": "264. 丑数 II", "slug": "/ugly-number-ii/", "src": "https://leetcode.cn/problems/ugly-number-ii/", "solution": null, "score": null, "isPremium": false}, {"id": 378, "title": "378. 有序矩阵中第 K 小的元素", "slug": "/kth-smallest-element-in-a-sorted-matrix/", "src": "https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/", "solution": null, "score": null, "isPremium": false}, {"id": 373, "title": "373. 查找和最小的 K 对数字", "slug": "/find-k-pairs-with-smallest-sums/", "src": "https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/", "solution": null, "score": null, "isPremium": false}, {"id": 1439, "title": "1439. 有序矩阵中的第 k 个最小数组和", "slug": "/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/", "src": "https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/", "solution": null, "score": 2133.9592509012, "isPremium": false}, {"id": 786, "title": "786. 第 K 个最小的质数分数", "slug": "/k-th-smallest-prime-fraction/", "src": "https://leetcode.cn/problems/k-th-smallest-prime-fraction/", "solution": null, "score": 2168.7531235448, "isPremium": false}, {"id": 2386, "title": "2386. 找出数组的第 K 大和", "slug": "/find-the-k-sum-of-an-array/", "src": "https://leetcode.cn/problems/find-the-k-sum-of-an-array/", "solution": null, "score": 2647.8258771458, "isPremium": false}]}, {"title": "§5.5 反悔堆", "summary": "基于堆的反悔贪心。<br>", "isLeaf": true, "children": [], "problems": [{"id": "LCP 30", "title": "LCP 30. 魔塔游戏", "slug": "/p0NxJO/", "src": "https://leetcode.cn/problems/p0NxJO/", "solution": null, "score": null, "isPremium": false}, {"id": 1642, "title": "1642. 可以到达的最远建筑", "slug": "/furthest-building-you-can-reach/", "src": "https://leetcode.cn/problems/furthest-building-you-can-reach/", "solution": null, "score": 1962.2005269503, "isPremium": false}, {"id": 630, "title": "630. 课程表 III", "slug": "/course-schedule-iii/", "src": "https://leetcode.cn/problems/course-schedule-iii/", "solution": null, "score": null, "isPremium": false}, {"id": 871, "title": "871. 最低加油次数", "slug": "/minimum-number-of-refueling-stops/", "src": "https://leetcode.cn/problems/minimum-number-of-refueling-stops/", "solution": null, "score": 2074.4120526679, "isPremium": false}, {"id": 3362, "title": "3362. 零数组变换 III", "slug": "/zero-array-transformation-iii/", "src": "https://leetcode.cn/problems/zero-array-transformation-iii/", "solution": null, "score": 2423.8553548566, "isPremium": false}, {"id": 2813, "title": "2813. 子序列最大优雅度", "slug": "/maximum-elegance-of-a-k-length-subsequence/", "src": "https://leetcode.cn/problems/maximum-elegance-of-a-k-length-subsequence/", "solution": null, "score": 2582.0814855506, "isPremium": false}, {"id": 3049, "title": "3049. 标记所有下标的最早秒数 II", "slug": "/earliest-second-to-mark-indices-ii/", "src": "https://leetcode.cn/problems/earliest-second-to-mark-indices-ii/", "solution": null, "score": 3111.1274320356, "isPremium": false}, {"id": 2599, "title": "2599. 使前缀和数组非负", "slug": "/make-the-prefix-sum-non-negative/", "src": "https://leetcode.cn/problems/make-the-prefix-sum-non-negative/", "solution": null, "score": null, "isPremium": true}]}, {"title": "§5.6 懒删除堆", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 2349, "title": "2349. 设计数字容器系统", "slug": "/design-a-number-container-system/", "src": "https://leetcode.cn/problems/design-a-number-container-system/", "solution": null, "score": 1540.2351411176, "isPremium": false}, {"id": 2353, "title": "2353. 设计食物评分系统", "slug": "/design-a-food-rating-system/", "src": "https://leetcode.cn/problems/design-a-food-rating-system/", "solution": null, "score": 1781.8156963676, "isPremium": false}, {"id": 3092, "title": "3092. 最高频率的 ID", "slug": "/most-frequent-ids/", "src": "https://leetcode.cn/problems/most-frequent-ids/", "solution": null, "score": 1793.1160019698, "isPremium": false}, {"id": 2034, "title": "2034. 股票价格波动", "slug": "/stock-price-fluctuation/", "src": "https://leetcode.cn/problems/stock-price-fluctuation/", "solution": null, "score": 1831.9395911303, "isPremium": false}, {"id": 1172, "title": "1172. 餐盘栈", "slug": "/dinner-plate-stacks/", "src": "https://leetcode.cn/problems/dinner-plate-stacks/", "solution": null, "score": 2109.9830154953, "isPremium": false}, {"id": 3391, "title": "3391. 设计一个高效的层跟踪三维二进制矩阵", "slug": "/design-a-3d-binary-matrix-with-efficient-layer-tracking/", "src": "https://leetcode.cn/problems/design-a-3d-binary-matrix-with-efficient-layer-tracking/", "solution": null, "score": null, "isPremium": true}]}, {"title": "§5.7 对顶堆（滑动窗口第 K 小/大）", "summary": "也可以用有序集合做。<br>另见 <a href=\"/lc-rating/list/graph\">图论题单</a> 中的 Dijkstra 算法。<br>", "isLeaf": true, "children": [], "problems": [{"id": 2102, "title": "2102. 序列顺序查询", "slug": "/sequentially-ordinal-rank-tracker/", "src": "https://leetcode.cn/problems/sequentially-ordinal-rank-tracker/", "solution": null, "score": 2158.7683843245, "isPremium": false}, {"id": 295, "title": "295. 数据流的中位数", "slug": "/find-median-from-data-stream/", "src": "https://leetcode.cn/problems/find-median-from-data-stream/", "solution": null, "score": null, "isPremium": false}, {"id": 480, "title": "480. 滑动窗口中位数", "slug": "/sliding-window-median/", "src": "https://leetcode.cn/problems/sliding-window-median/", "solution": null, "score": null, "isPremium": false}, {"id": 1825, "title": "1825. 求出 MK 平均值", "slug": "/finding-mk-average/", "src": "https://leetcode.cn/problems/finding-mk-average/", "solution": null, "score": 2395.8765531206, "isPremium": false}, {"id": 3013, "title": "3013. 将数组分成最小总代价的子数组 II", "slug": "/divide-an-array-into-subarrays-with-minimum-cost-ii/", "src": "https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/", "solution": null, "score": 2540.438150736, "isPremium": false}, {"id": 3321, "title": "3321. 计算子数组的 x-sum II", "slug": "/find-x-sum-of-all-k-long-subarrays-ii/", "src": "https://leetcode.cn/problems/find-x-sum-of-all-k-long-subarrays-ii/", "solution": null, "score": 2598.4563109814, "isPremium": false}, {"id": "LCP 24", "title": "LCP 24. 数字游戏", "slug": "/5TxKeK/", "src": "https://leetcode.cn/problems/5TxKeK/", "solution": null, "score": null, "isPremium": false}, {"id": 3369, "title": "3369. 设计数组统计跟踪器", "slug": "/design-an-array-statistics-tracker/", "src": "https://leetcode.cn/problems/design-an-array-statistics-tracker/", "solution": null, "score": null, "isPremium": true}, {"id": 3422, "title": "3422. 将子数组元素变为相等所需的最小操作数", "slug": "/minimum-operations-to-make-subarray-elements-equal/", "src": "https://leetcode.cn/problems/minimum-operations-to-make-subarray-elements-equal/", "solution": null, "score": null, "isPremium": true}]}], "problems": []}, {"title": "六、字典树（trie）", "summary": "", "isLeaf": false, "children": [{"title": "§6.1 基础", "summary": "<a href=\"https://leetcode.cn/problems/implement-trie-prefix-tree/solutions/2993894/cong-er-cha-shu-dao-er-shi-liu-cha-shu-p-xsj4/\">模板</a><br>", "isLeaf": true, "children": [], "problems": [{"id": 208, "title": "208. 实现 Trie (前缀树)", "slug": "/implement-trie-prefix-tree/", "src": "https://leetcode.cn/problems/implement-trie-prefix-tree/", "solution": null, "score": null, "isPremium": false}, {"id": 211, "title": "211. 添加与搜索单词 - 数据结构设计", "slug": "/design-add-and-search-words-data-structure/", "src": "https://leetcode.cn/problems/design-add-and-search-words-data-structure/", "solution": null, "score": null, "isPremium": false}, {"id": 14, "title": "14. 最长公共前缀", "slug": "/longest-common-prefix/", "src": "https://leetcode.cn/problems/longest-common-prefix/", "solution": null, "score": null, "isPremium": false}, {"id": 648, "title": "648. 单词替换", "slug": "/replace-words/", "src": "https://leetcode.cn/problems/replace-words/", "solution": null, "score": null, "isPremium": false}, {"id": 677, "title": "677. 键值映射", "slug": "/map-sum-pairs/", "src": "https://leetcode.cn/problems/map-sum-pairs/", "solution": null, "score": null, "isPremium": false}, {"id": 720, "title": "720. 词典中最长的单词", "slug": "/longest-word-in-dictionary/", "src": "https://leetcode.cn/problems/longest-word-in-dictionary/", "solution": null, "score": null, "isPremium": false}, {"id": 1268, "title": "1268. 搜索推荐系统", "slug": "/search-suggestions-system/", "src": "https://leetcode.cn/problems/search-suggestions-system/", "solution": null, "score": 1573.4042963622, "isPremium": false}, {"id": 1233, "title": "1233. 删除子文件夹", "slug": "/remove-sub-folders-from-the-filesystem/", "src": "https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/", "solution": null, "score": 1544.8261365027, "isPremium": false}, {"id": 820, "title": "820. 单词的压缩编码", "slug": "/short-encoding-of-words/", "src": "https://leetcode.cn/problems/short-encoding-of-words/", "solution": null, "score": 1632.0191837349, "isPremium": false}, {"id": 2416, "title": "2416. 字符串的前缀分数和", "slug": "/sum-of-prefix-scores-of-strings/", "src": "https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/", "solution": null, "score": 1725.1995150882, "isPremium": false}, {"id": 2261, "title": "2261. 含最多 K 个可整除元素的子数组", "slug": "/k-divisible-elements-subarrays/", "src": "https://leetcode.cn/problems/k-divisible-elements-subarrays/", "solution": null, "score": 1724.394164934, "isPremium": false}, {"id": 1804, "title": "1804. 实现 Trie （前缀树） II", "slug": "/implement-trie-ii-prefix-tree/", "src": "https://leetcode.cn/problems/implement-trie-ii-prefix-tree/", "solution": null, "score": null, "isPremium": true}, {"id": 2168, "title": "2168. 每个数字的频率都相同的独特子字符串的数量", "slug": "/unique-substrings-with-equal-digit-frequency/", "src": "https://leetcode.cn/problems/unique-substrings-with-equal-digit-frequency/", "solution": null, "score": null, "isPremium": true}]}, {"title": "§6.2 进阶", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 676, "title": "676. 实现一个魔法字典", "slug": "/implement-magic-dictionary/", "src": "https://leetcode.cn/problems/implement-magic-dictionary/", "solution": null, "score": null, "isPremium": false}, {"id": 212, "title": "212. 单词搜索 II", "slug": "/word-search-ii/", "src": "https://leetcode.cn/problems/word-search-ii/", "solution": null, "score": null, "isPremium": false}, {"id": 3093, "title": "3093. 最长公共后缀查询", "slug": "/longest-common-suffix-queries/", "src": "https://leetcode.cn/problems/longest-common-suffix-queries/", "solution": null, "score": 2118.3732356694, "isPremium": false}, {"id": 745, "title": "745. 前缀和后缀搜索", "slug": "/prefix-and-suffix-search/", "src": "https://leetcode.cn/problems/prefix-and-suffix-search/", "solution": null, "score": null, "isPremium": false}, {"id": 3045, "title": "3045. 统计前后缀下标对 II", "slug": "/count-prefix-and-suffix-pairs-ii/", "src": "https://leetcode.cn/problems/count-prefix-and-suffix-pairs-ii/", "solution": null, "score": 2327.5726642605, "isPremium": false}, {"id": 336, "title": "336. 回文对", "slug": "/palindrome-pairs/", "src": "https://leetcode.cn/problems/palindrome-pairs/", "solution": null, "score": null, "isPremium": false}, {"id": 1948, "title": "1948. 删除系统中的重复文件夹", "slug": "/delete-duplicate-folders-in-system/", "src": "https://leetcode.cn/problems/delete-duplicate-folders-in-system/", "solution": null, "score": 2533.7796160302, "isPremium": false}, {"id": 425, "title": "425. 单词方块", "slug": "/word-squares/", "src": "https://leetcode.cn/problems/word-squares/", "solution": null, "score": null, "isPremium": true}, {"id": 527, "title": "527. 单词缩写", "slug": "/word-abbreviation/", "src": "https://leetcode.cn/problems/word-abbreviation/", "solution": null, "score": null, "isPremium": true}, {"id": 588, "title": "588. 设计内存文件系统", "slug": "/design-in-memory-file-system/", "src": "https://leetcode.cn/problems/design-in-memory-file-system/", "solution": null, "score": null, "isPremium": true}, {"id": 616, "title": "616. 给字符串添加加粗标签", "slug": "/add-bold-tag-in-string/", "src": "https://leetcode.cn/problems/add-bold-tag-in-string/", "solution": null, "score": null, "isPremium": true}, {"id": 758, "title": "758. 字符串中的加粗单词", "slug": "/bold-words-in-string/", "src": "https://leetcode.cn/problems/bold-words-in-string/", "solution": null, "score": 1547.0385279086, "isPremium": true}, {"id": 642, "title": "642. 设计搜索自动补全系统", "slug": "/design-search-autocomplete-system/", "src": "https://leetcode.cn/problems/design-search-autocomplete-system/", "solution": null, "score": null, "isPremium": true}, {"id": 1065, "title": "1065. 字符串的索引对", "slug": "/index-pairs-of-a-string/", "src": "https://leetcode.cn/problems/index-pairs-of-a-string/", "solution": null, "score": 1389.331169471, "isPremium": true}, {"id": 1166, "title": "1166. 设计文件系统", "slug": "/design-file-system/", "src": "https://leetcode.cn/problems/design-file-system/", "solution": null, "score": 1479.0110934646, "isPremium": true}, {"id": 1858, "title": "1858. 包含所有前缀的最长单词", "slug": "/longest-word-with-all-prefixes/", "src": "https://leetcode.cn/problems/longest-word-with-all-prefixes/", "solution": null, "score": null, "isPremium": true}]}, {"title": "§6.3 字典树优化 DP", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 139, "title": "139. 单词拆分", "slug": "/word-break/", "src": "https://leetcode.cn/problems/word-break/", "solution": null, "score": null, "isPremium": false}, {"id": 140, "title": "140. 单词拆分 II", "slug": "/word-break-ii/", "src": "https://leetcode.cn/problems/word-break-ii/", "solution": null, "score": null, "isPremium": false}, {"id": "面试题 17.13", "title": "面试题 17.13. 恢复空格", "slug": "/re-space-lcci/", "src": "https://leetcode.cn/problems/re-space-lcci/", "solution": null, "score": null, "isPremium": false}, {"id": 472, "title": "472. 连接词", "slug": "/concatenated-words/", "src": "https://leetcode.cn/problems/concatenated-words/", "solution": null, "score": null, "isPremium": false}, {"id": 2977, "title": "2977. 转换字符串的最小成本 II", "slug": "/minimum-cost-to-convert-string-ii/", "src": "https://leetcode.cn/problems/minimum-cost-to-convert-string-ii/", "solution": null, "score": 2695.809667046, "isPremium": false}]}, {"title": "§6.4 0-1 字典树（异或字典树）", "summary": "部分题目也可以用试填法解决。<br>", "isLeaf": true, "children": [], "problems": [{"id": 421, "title": "421. 数组中两个数的最大异或值", "slug": "/maximum-xor-of-two-numbers-in-an-array/", "src": "https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/", "solution": null, "score": null, "isPremium": false}, {"id": 2935, "title": "2935. 找出强数对的最大异或值 II", "slug": "/maximum-strong-pair-xor-ii/", "src": "https://leetcode.cn/problems/maximum-strong-pair-xor-ii/", "solution": null, "score": 2348.7273357105, "isPremium": false}, {"id": 1707, "title": "1707. 与数组中元素的最大异或值", "slug": "/maximum-xor-with-an-element-from-array/", "src": "https://leetcode.cn/problems/maximum-xor-with-an-element-from-array/", "solution": null, "score": 2358.9669560824, "isPremium": false}, {"id": 1803, "title": "1803. 统计异或值在范围内的数对有多少", "slug": "/count-pairs-with-xor-in-a-range/", "src": "https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/", "solution": null, "score": 2479.3282985529, "isPremium": false}, {"id": 1938, "title": "1938. 查询最大基因差", "slug": "/maximum-genetic-difference-query/", "src": "https://leetcode.cn/problems/maximum-genetic-difference-query/", "solution": null, "score": 2502.5176603922, "isPremium": false}, {"id": 2479, "title": "2479. 两个不重叠子树的最大异或值", "slug": "/maximum-xor-of-two-non-overlapping-subtrees/", "src": "https://leetcode.cn/problems/maximum-xor-of-two-non-overlapping-subtrees/", "solution": null, "score": null, "isPremium": true}]}], "problems": []}, {"title": "七、并查集", "summary": "", "isLeaf": false, "children": [{"title": "§7.1 基础", "summary": "更多基础题，见 <a href=\"/lc-rating/list/grid\">网格图题单</a> 中的 DFS 和 <a href=\"/lc-rating/list/graph\">图论题单</a> 中的 DFS，其中大部分题目也可以用并查集实现。<br>", "isLeaf": true, "children": [], "problems": [{"id": 990, "title": "990. 等式方程的可满足性", "slug": "/satisfiability-of-equality-equations/", "src": "https://leetcode.cn/problems/satisfiability-of-equality-equations/", "solution": null, "score": 1638.0148920643, "isPremium": false}, {"id": 721, "title": "721. 账户合并", "slug": "/accounts-merge/", "src": "https://leetcode.cn/problems/accounts-merge/", "solution": null, "score": null, "isPremium": false}, {"id": 737, "title": "737. 句子相似性 II", "slug": "/sentence-similarity-ii/", "src": "https://leetcode.cn/problems/sentence-similarity-ii/", "solution": null, "score": null, "isPremium": true}, {"id": 1101, "title": "1101. 彼此熟识的最早时间", "slug": "/the-earliest-moment-when-everyone-become-friends/", "src": "https://leetcode.cn/problems/the-earliest-moment-when-everyone-become-friends/", "solution": null, "score": 1558.4971807039, "isPremium": true}, {"id": 1258, "title": "1258. 近义词句子", "slug": "/synonymous-sentences/", "src": "https://leetcode.cn/problems/synonymous-sentences/", "solution": null, "score": 1847.2077654978, "isPremium": true}]}, {"title": "§7.2 进阶", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 1202, "title": "1202. 交换字符串中的元素", "slug": "/smallest-string-with-swaps/", "src": "https://leetcode.cn/problems/smallest-string-with-swaps/", "solution": null, "score": 1855.4479039876, "isPremium": false}, {"id": 1061, "title": "1061. 按字典序排列最小的等效字符串", "slug": "/lexicographically-smallest-equivalent-string/", "src": "https://leetcode.cn/problems/lexicographically-smallest-equivalent-string/", "solution": null, "score": null, "isPremium": false}, {"id": 1722, "title": "1722. 执行交换操作后的最小汉明距离", "slug": "/minimize-hamming-distance-after-swap-operations/", "src": "https://leetcode.cn/problems/minimize-hamming-distance-after-swap-operations/", "solution": null, "score": 1892.1600619469, "isPremium": false}, {"id": 765, "title": "765. 情侣牵手", "slug": "/couples-holding-hands/", "src": "https://leetcode.cn/problems/couples-holding-hands/", "solution": null, "score": 1999.1208076854, "isPremium": false}, {"id": 684, "title": "684. 冗余连接", "slug": "/redundant-connection/", "src": "https://leetcode.cn/problems/redundant-connection/", "solution": null, "score": null, "isPremium": false}, {"id": 685, "title": "685. 冗余连接 II", "slug": "/redundant-connection-ii/", "src": "https://leetcode.cn/problems/redundant-connection-ii/", "solution": null, "score": null, "isPremium": false}, {"id": 947, "title": "947. 移除最多的同行或同列石头", "slug": "/most-stones-removed-with-same-row-or-column/", "src": "https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/", "solution": null, "score": 2034.6759416871, "isPremium": false}, {"id": 839, "title": "839. 相似字符串组", "slug": "/similar-string-groups/", "src": "https://leetcode.cn/problems/similar-string-groups/", "solution": null, "score": 2053.7468090497, "isPremium": false}, {"id": 1970, "title": "1970. 你能穿过矩阵的最后一天", "slug": "/last-day-where-you-can-still-cross/", "src": "https://leetcode.cn/problems/last-day-where-you-can-still-cross/", "solution": null, "score": 2123.5708982185, "isPremium": false}, {"id": 2076, "title": "2076. 处理含限制条件的好友请求", "slug": "/process-restricted-friend-requests/", "src": "https://leetcode.cn/problems/process-restricted-friend-requests/", "solution": null, "score": 2130.9348604091, "isPremium": false}, {"id": 1579, "title": "1579. 保证图可完全遍历", "slug": "/remove-max-number-of-edges-to-keep-graph-fully-traversable/", "src": "https://leetcode.cn/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/", "solution": null, "score": 2131.7917160422, "isPremium": false}, {"id": 959, "title": "959. 由斜杠划分区域", "slug": "/regions-cut-by-slashes/", "src": "https://leetcode.cn/problems/regions-cut-by-slashes/", "solution": null, "score": 2135.5738659086, "isPremium": false}, {"id": 2812, "title": "2812. 找出最安全路径", "slug": "/find-the-safest-path-in-a-grid/", "src": "https://leetcode.cn/problems/find-the-safest-path-in-a-grid/", "solution": null, "score": 2153.5854429139, "isPremium": false}, {"id": 2503, "title": "2503. 矩阵查询可获得的最大分数", "slug": "/maximum-number-of-points-from-grid-queries/", "src": "https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/", "solution": null, "score": 2195.6540241654, "isPremium": false}, {"id": 2867, "title": "2867. 统计树中的合法路径数目", "slug": "/count-valid-paths-in-a-tree/", "src": "https://leetcode.cn/problems/count-valid-paths-in-a-tree/", "solution": null, "score": 2428.3242593838, "isPremium": false}, {"id": 2421, "title": "2421. 好路径的数目", "slug": "/number-of-good-paths/", "src": "https://leetcode.cn/problems/number-of-good-paths/", "solution": null, "score": 2444.6660756903, "isPremium": false}, {"id": 2157, "title": "2157. 字符串分组", "slug": "/groups-of-strings/", "src": "https://leetcode.cn/problems/groups-of-strings/", "solution": null, "score": 2499.3282271507, "isPremium": false}, {"id": 1632, "title": "1632. 矩阵转换后的秩", "slug": "/rank-transform-of-a-matrix/", "src": "https://leetcode.cn/problems/rank-transform-of-a-matrix/", "solution": null, "score": 2529.5251086936, "isPremium": false}, {"id": 803, "title": "803. 打砖块", "slug": "/bricks-falling-when-hit/", "src": "https://leetcode.cn/problems/bricks-falling-when-hit/", "solution": null, "score": 2765.2533837781, "isPremium": false}, {"id": 1569, "title": "1569. 将子数组重新排序得到同一个二叉搜索树的方案数", "slug": "/number-of-ways-to-reorder-array-to-get-same-bst/", "src": "https://leetcode.cn/problems/number-of-ways-to-reorder-array-to-get-same-bst/", "solution": null, "score": 2288.2117442123, "isPremium": false}, {"id": 3235, "title": "3235. 判断矩形的两个角落是否可达", "slug": "/check-if-the-rectangle-corner-is-reachable/", "src": "https://leetcode.cn/problems/check-if-the-rectangle-corner-is-reachable/", "solution": null, "score": 3773.7596150919, "isPremium": false}, {"id": "LCP 71", "title": "LCP 71. 集水器", "slug": "/kskhHQ/", "src": "https://leetcode.cn/problems/kskhHQ/", "solution": null, "score": null, "isPremium": false}, {"id": 2371, "title": "2371. 最小化网格中的最大值", "slug": "/minimize-maximum-value-in-a-grid/", "src": "https://leetcode.cn/problems/minimize-maximum-value-in-a-grid/", "solution": null, "score": null, "isPremium": true}, {"id": 2459, "title": "2459. 通过移动项目到空白区域来排序数组", "slug": "/sort-array-by-moving-items-to-empty-space/", "src": "https://leetcode.cn/problems/sort-array-by-moving-items-to-empty-space/", "solution": null, "score": null, "isPremium": true}]}, {"title": "§7.3 GCD 并查集", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 2709, "title": "2709. 最大公约数遍历", "slug": "/greatest-common-divisor-traversal/", "src": "https://leetcode.cn/problems/greatest-common-divisor-traversal/", "solution": null, "score": 2171.9645269732, "isPremium": false}, {"id": 1627, "title": "1627. 带阈值的图连通性", "slug": "/graph-connectivity-with-threshold/", "src": "https://leetcode.cn/problems/graph-connectivity-with-threshold/", "solution": null, "score": 2221.3538766773, "isPremium": false}, {"id": 952, "title": "952. 按公因数计算最大组件大小", "slug": "/largest-component-size-by-common-factor/", "src": "https://leetcode.cn/problems/largest-component-size-by-common-factor/", "solution": null, "score": 2272.1122260637, "isPremium": false}, {"id": 1998, "title": "1998. 数组的最大公因数排序", "slug": "/gcd-sort-of-an-array/", "src": "https://leetcode.cn/problems/gcd-sort-of-an-array/", "solution": null, "score": 2429.0940568399, "isPremium": false}, {"id": 3378, "title": "3378. 统计最小公倍数图中的连通块数目", "slug": "/count-connected-components-in-lcm-graph/", "src": "https://leetcode.cn/problems/count-connected-components-in-lcm-graph/", "solution": null, "score": 2532.0192714689, "isPremium": false}]}, {"title": "§7.4 数组上的并查集", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 1562, "title": "1562. 查找大小为 M 的最新分组", "slug": "/find-latest-group-of-size-m/", "src": "https://leetcode.cn/problems/find-latest-group-of-size-m/", "solution": null, "score": 1928.2304187946, "isPremium": false}, {"id": 1488, "title": "1488. 避免洪水泛滥", "slug": "/avoid-flood-in-the-city/", "src": "https://leetcode.cn/problems/avoid-flood-in-the-city/", "solution": null, "score": 1973.7407637067, "isPremium": false}, {"id": 2382, "title": "2382. 删除操作后的最大子段和", "slug": "/maximum-segment-sum-after-removals/", "src": "https://leetcode.cn/problems/maximum-segment-sum-after-removals/", "solution": null, "score": 2136.3013259524, "isPremium": false}, {"id": 2334, "title": "2334. 元素值大于变化阈值的子数组", "slug": "/subarray-with-elements-greater-than-varying-threshold/", "src": "https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/", "solution": null, "score": 2381.2160234811, "isPremium": false}, {"id": 2612, "title": "2612. 最少翻转操作数", "slug": "/minimum-reverse-operations/", "src": "https://leetcode.cn/problems/minimum-reverse-operations/", "solution": null, "score": 2824.4551372454, "isPremium": false}]}, {"title": "§7.5 区间并查集", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 1851, "title": "1851. 包含每个查询的最小区间", "slug": "/minimum-interval-to-include-each-query/", "src": "https://leetcode.cn/problems/minimum-interval-to-include-each-query/", "solution": null, "score": 2286.1378742318, "isPremium": false}, {"id": 3244, "title": "3244. 新增道路查询后的最短距离 II", "slug": "/shortest-distance-after-road-addition-queries-ii/", "src": "https://leetcode.cn/problems/shortest-distance-after-road-addition-queries-ii/", "solution": null, "score": 2270.2002503611, "isPremium": false}, {"id": 2158, "title": "2158. 每天绘制新区域的数量", "slug": "/amount-of-new-area-painted-each-day/", "src": "https://leetcode.cn/problems/amount-of-new-area-painted-each-day/", "solution": null, "score": null, "isPremium": true}]}, {"title": "§7.6 边权并查集", "summary": "", "isLeaf": true, "children": [], "problems": [{"id": 399, "title": "399. 除法求值", "slug": "/evaluate-division/", "src": "https://leetcode.cn/problems/evaluate-division/", "solution": null, "score": null, "isPremium": false}, {"id": 2307, "title": "2307. 检查方程中的矛盾之处", "slug": "/check-for-contradictions-in-equations/", "src": "https://leetcode.cn/problems/check-for-contradictions-in-equations/", "solution": null, "score": null, "isPremium": true}]}], "problems": []}, {"title": "八、树状数组和线段树", "summary": "能用树状数组解决的题目，也能用线段树解决（反过来不一定）。但树状数组实现简单，代码短。<br>为方便大家练习，我把适合用树状数组解决的题目分到树状数组中，其余分到线段树中。<br>", "isLeaf": false, "children": [{"title": "时间复杂度 O(log n)", "summary": "讲解：<a href=\"https://leetcode.cn/problems/range-sum-query-mutable/solution/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll/\">带你发明树状数组！附数学证明</a><br>模板：<br>```py [sol-Python3]<br>class FenwickTree:<br>def __init__(self, n: int):<br>self.tree = [0] * (n + 1)  # 使用下标 1 到 n<br>def update(self, i: int, val: int) -> None:<br>while i < len(self.tree):<br>self.tree[i] += val<br>i += i & -i<br>def pre(self, i: int) -> int:<br>res = 0<br>while i > 0:<br>res += self.tree[i]<br>i &= i - 1<br>return res<br>def query(self, l: int, r: int) -> int:<br>if r < l:<br>return 0<br>return self.pre(r) - self.pre(l - 1)<br>```<br>```java [sol-Java]<br>class FenwickTree {<br>private final long[] tree; // 如果计算结果没有超出 int 范围，可以改成 int<br>public FenwickTree(int n) {<br>tree = new long[n + 1]; // 使用下标 1 到 n<br>}<br>// a[i] 增加 val<br>// 1 <= i <= n<br>// 时间复杂度 O(log n)<br>public void update(int i, long val) {<br>for (; i < tree.length; i += i & -i) {<br>tree[i] += val;<br>}<br>}<br>// 求前缀和 a[1] + ... + a[i]<br>// 1 <= i <= n<br>// 时间复杂度 O(log n)<br>public long pre(int i) {<br>long res = 0;<br>for (; i > 0; i &= i - 1) {<br>res += tree[i];<br>}<br>return res;<br>}<br>// 求区间和 a[l] + ... + a[r]<br>// 1 <= l <= r <= n<br>// 时间复杂度 O(log n)<br>public long query(int l, int r) {<br>if (r < l) {<br>return 0;<br>}<br>return pre(r) - pre(l - 1);<br>}<br>}<br>```<br>```cpp [sol-C++]<br>// 根据题目用 FenwickTree<int> t(n) 或者 FenwickTree<long long> t(n) 初始化<br>template<typename T><br>class FenwickTree {<br>vector<T> tree;<br>public:<br>// 使用下标 1 到 n<br>FenwickTree(int n) : tree(n + 1) {}<br>// a[i] 增加 val<br>// 1 <= i <= n<br>// 时间复杂度 O(log n)<br>void update(int i, T val) {<br>for (; i < tree.size(); i += i & -i) {<br>tree[i] += val;<br>}<br>}<br>// 求前缀和 a[1] + ... + a[i]<br>// 1 <= i <= n<br>// 时间复杂度 O(log n)<br>T pre(int i) const {<br>T res = 0;<br>for (; i > 0; i &= i - 1) {<br>res += tree[i];<br>}<br>return res;<br>}<br>// 求区间和 a[l] + ... + a[r]<br>// 1 <= l <= r <= n<br>// 时间复杂度 O(log n)<br>T query(int l, int r) const {<br>if (r < l) {<br>return 0;<br>}<br>return pre(r) - pre(l - 1);<br>}<br>};<br>```<br>```go [sol-Go]<br>type fenwick []int<br>func newFenwickTree(n int) fenwick {<br>return make(fenwick, n+1) // 使用下标 1 到 n<br>}<br>// a[i] 增加 val<br>// 1 <= i <= n<br>// 时间复杂度 O(log n)<br>func (f fenwick) update(i int, val int) {<br>for ; i < len(f); i += i & -i {<br>f[i] += val<br>}<br>}<br>// 求前缀和 a[1] + ... + a[i]<br>// 1 <= i <= n<br>// 时间复杂度 O(log n)<br>func (f fenwick) pre(i int) (res int) {<br>for ; i > 0; i &= i - 1 {<br>res += f[i]<br>}<br>return<br>}<br>// 求区间和 a[l] + ... + a[r]<br>// 1 <= l <= r <= n<br>// 时间复杂度 O(log n)<br>func (f fenwick) query(l, r int) int {<br>if r < l {<br>return 0<br>}<br>return f.pre(r) - f.pre(l-1)<br>}<br>```<br>", "isLeaf": true, "children": [], "problems": [{"id": 307, "title": "307. 区域和检索 - 数组可修改", "slug": "/range-sum-query-mutable/", "src": "https://leetcode.cn/problems/range-sum-query-mutable/", "solution": null, "score": null, "isPremium": false}, {"id": 3072, "title": "3072. 将元素分配到两个数组中 II", "slug": "/distribute-elements-into-two-arrays-ii/", "src": "https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/", "solution": null, "score": 2052.8622720512, "isPremium": false}, {"id": 3187, "title": "3187. 数组中的峰值", "slug": "/peaks-in-array/", "src": "https://leetcode.cn/problems/peaks-in-array/", "solution": null, "score": 2154.4458036869, "isPremium": false}, {"id": 1649, "title": "1649. 通过指令创建有序数组", "slug": "/create-sorted-array-through-instructions/", "src": "https://leetcode.cn/problems/create-sorted-array-through-instructions/", "solution": null, "score": 2207.8565809952, "isPremium": false}, {"id": 1626, "title": "1626. 无矛盾的最佳球队", "slug": "/best-team-with-no-conflicts/", "src": "https://leetcode.cn/problems/best-team-with-no-conflicts/", "solution": null, "score": 2027.3839266711, "isPremium": false}, {"id": 1409, "title": "1409. 查询带键的排列", "slug": "/queries-on-a-permutation-with-key/", "src": "https://leetcode.cn/problems/queries-on-a-permutation-with-key/", "solution": null, "score": 1334.5718985411, "isPremium": false}, {"id": 2250, "title": "2250. 统计包含每个点的矩形数目", "slug": "/count-number-of-rectangles-containing-each-point/", "src": "https://leetcode.cn/problems/count-number-of-rectangles-containing-each-point/", "solution": null, "score": 1997.7013718153, "isPremium": false}, {"id": 2179, "title": "2179. 统计数组中好三元组数目", "slug": "/count-good-triplets-in-an-array/", "src": "https://leetcode.cn/problems/count-good-triplets-in-an-array/", "solution": null, "score": 2272.4412003208, "isPremium": false}, {"id": 1395, "title": "1395. 统计作战单位数", "slug": "/count-number-of-teams/", "src": "https://leetcode.cn/problems/count-number-of-teams/", "solution": null, "score": 1343.628913055, "isPremium": false}, {"id": 2659, "title": "2659. 将数组清空", "slug": "/make-array-empty/", "src": "https://leetcode.cn/problems/make-array-empty/", "solution": null, "score": 2281.8816902545, "isPremium": false}, {"id": 2653, "title": "2653. 滑动子数组的美丽值", "slug": "/sliding-subarray-beauty/", "src": "https://leetcode.cn/problems/sliding-subarray-beauty/", "solution": null, "score": 1785.6006955353, "isPremium": false}, {"id": 1505, "title": "1505. 最多 K 次交换相邻数位后得到的最小整数", "slug": "/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/", "src": "https://leetcode.cn/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/", "solution": null, "score": 2336.5210003185, "isPremium": false}, {"id": 2926, "title": "2926. 平衡子序列的最大和", "slug": "/maximum-balanced-subsequence-sum/", "src": "https://leetcode.cn/problems/maximum-balanced-subsequence-sum/", "solution": null, "score": 2448.4455464535, "isPremium": false}, {"id": 2736, "title": "2736. 最大和查询", "slug": "/maximum-sum-queries/", "src": "https://leetcode.cn/problems/maximum-sum-queries/", "solution": null, "score": 2533.2830157959, "isPremium": false}, {"id": 3382, "title": "3382. 用点构造面积最大的矩形 II", "slug": "/maximum-area-rectangle-with-point-constraints-ii/", "src": "https://leetcode.cn/problems/maximum-area-rectangle-with-point-constraints-ii/", "solution": null, "score": 2722.8634460016, "isPremium": false}, {"id": 3245, "title": "3245. 交替组 III", "slug": "/alternating-groups-iii/", "src": "https://leetcode.cn/problems/alternating-groups-iii/", "solution": null, "score": 3112.0402038423, "isPremium": false}, {"id": 1756, "title": "1756. 设计最近使用（MRU）队列", "slug": "/design-most-recently-used-queue/", "src": "https://leetcode.cn/problems/design-most-recently-used-queue/", "solution": null, "score": null, "isPremium": true}, {"id": 60, "title": "60. 排列序列", "slug": "/permutation-sequence/", "src": "https://leetcode.cn/problems/permutation-sequence/", "solution": null, "score": null, "isPremium": false}, {"id": 3109, "title": "3109. 查找排列的下标", "slug": "/find-the-index-of-permutation/", "src": "https://leetcode.cn/problems/find-the-index-of-permutation/", "solution": null, "score": null, "isPremium": true}, {"id": 2519, "title": "2519. 统计 K-Big 索引的数量", "slug": "/count-the-number-of-k-big-indices/", "src": "https://leetcode.cn/problems/count-the-number-of-k-big-indices/", "solution": null, "score": null, "isPremium": true}, {"id": 2613, "title": "2613. 美数对", "slug": "/beautiful-pairs/", "src": "https://leetcode.cn/problems/beautiful-pairs/", "solution": null, "score": null, "isPremium": true}, {"id": 2921, "title": "2921. 价格递增的最大利润三元组 II", "slug": "/maximum-profitable-triplets-with-increasing-prices-ii/", "src": "https://leetcode.cn/problems/maximum-profitable-triplets-with-increasing-prices-ii/", "solution": null, "score": null, "isPremium": true}, {"id": 308, "title": "308. 二维区域和检索 - 可变", "slug": "/range-sum-query-2d-mutable/", "src": "https://leetcode.cn/problems/range-sum-query-2d-mutable/", "solution": null, "score": null, "isPremium": true}]}, {"title": "§8.2 逆序对", "summary": "除了可以用树状数组解决，部分题目也可以在**归并排序**的同时计算。<br>", "isLeaf": true, "children": [], "problems": [{"id": "LCR 170", "title": "LCR 170. 交易逆序对的总数", "slug": "/shu-zu-zhong-de-ni-xu-dui-lcof/", "src": "https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/", "solution": null, "score": null, "isPremium": false}, {"id": 315, "title": "315. 计算右侧小于当前元素的个数", "slug": "/count-of-smaller-numbers-after-self/", "src": "https://leetcode.cn/problems/count-of-smaller-numbers-after-self/", "solution": null, "score": null, "isPremium": false}, {"id": 493, "title": "493. 翻转对", "slug": "/reverse-pairs/", "src": "https://leetcode.cn/problems/reverse-pairs/", "solution": null, "score": null, "isPremium": false}, {"id": 327, "title": "327. 区间和的个数", "slug": "/count-of-range-sum/", "src": "https://leetcode.cn/problems/count-of-range-sum/", "solution": null, "score": null, "isPremium": false}, {"id": 2426, "title": "2426. 满足不等式的数对数目", "slug": "/number-of-pairs-satisfying-inequality/", "src": "https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/", "solution": null, "score": 2030.1021023033, "isPremium": false}, {"id": 1850, "title": "1850. 邻位交换的最小次数", "slug": "/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/", "src": "https://leetcode.cn/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/", "solution": null, "score": 2073.0124645606, "isPremium": false}, {"id": 2193, "title": "2193. 得到回文串的最少操作次数", "slug": "/minimum-number-of-moves-to-make-palindrome/", "src": "https://leetcode.cn/problems/minimum-number-of-moves-to-make-palindrome/", "solution": null, "score": 2090.6800569319, "isPremium": false}, {"id": 1885, "title": "1885. 统计数对", "slug": "/count-pairs-in-two-arrays/", "src": "https://leetcode.cn/problems/count-pairs-in-two-arrays/", "solution": null, "score": null, "isPremium": true}]}, {"title": "§8.3 线段树（无区间更新）", "summary": "线段树本质是二叉树，在学习之前，建议先做做 <a href=\"https://leetcode.cn/problems/maximum-depth-of-binary-tree/\">104. 二叉树的最大深度</a> 和 <a href=\"https://leetcode.cn/problems/minimum-depth-of-binary-tree/\">111. 二叉树的最小深度</a>（自底向上写法），当作热身。<br><a href=\"https://www.bilibili.com/video/BV15gRaYZE5o/\">线段树：为什么要这样设计？</a> 理解线段树发明的动机。<br>基础模板代码如下。为方便入门理解，我没有做复杂封装。通用模板代码可以参考 AtCoder Library 的 <a href=\"https://github.com/atcoder/ac-library/blob/master/atcoder/segtree.hpp\">segtree.hpp</a>。<br>```py [sol-Python3]<br>", "isLeaf": false, "children": [], "problems": []}], "problems": []}], "problems": []}, {"title": "线段树有两个下标，一个是线段树节点的下标，另一个是线段树维护的区间的下标", "summary": "", "isLeaf": false, "children": [], "problems": []}, {"title": "节点的下标：从 1 开始，如果你想改成从 0 开始，需要把左右儿子下标分别改成 node*2+1 和 node*2+2", "summary": "", "isLeaf": false, "children": [], "problems": []}, {"title": "时间复杂度 O(log n)", "summary": "class SegmentTree:<br>def __init__(self, n: int, init_val=0):<br>if isinstance(init_val, int):<br>init_val = [init_val] * n<br>self._n = n<br>self._tree = [0] * (2 << (n - 1).bit_length())<br>self._build(init_val, 1, 0, n - 1)<br>def _merge_val(self, a: int, b: int) -> int:<br>return max(a, b)  # **根据题目修改**<br>def _maintain(self, node: int) -> None:<br>self._tree[node] = self._merge_val(self._tree[node * 2], self._tree[node * 2 + 1])<br>def _build(self, a: List[int], node: int, l: int, r: int) -> None:<br>if l == r:  # 叶子<br>self._tree[node] = a[l]  # 初始化叶节点的值<br>return<br>m = (l + r) // 2<br>self._build(a, node * 2, l, m)  # 初始化左子树<br>self._build(a, node * 2 + 1, m + 1, r)  # 初始化右子树<br>self._maintain(node)<br>def _update(self, node: int, l: int, r: int, i: int, val: int) -> None:<br>if l == r:  # 叶子（到达目标）<br>self._tree[node] = self._merge_val(self._tree[node], val)<br>return<br>m = (l + r) // 2<br>if i <= m:  # i 在左子树<br>self._update(node * 2, l, m, i, val)<br>else:  # i 在右子树<br>self._update(node * 2 + 1, m + 1, r, i, val)<br>self._maintain(node)<br>def _query(self, node: int, l: int, r: int, ql: int, qr: int) -> int:<br>if ql <= l and r <= qr:  # 当前子树完全在 [ql, qr] 内<br>return self._tree[node]<br>m = (l + r) // 2<br>if qr <= m:  # [ql, qr] 在左子树<br>return self._query(node * 2, l, m, ql, qr)<br>if ql > m:  # [ql, qr] 在右子树<br>return self._query(node * 2 + 1, m + 1, r, ql, qr)<br>l_res = self._query(node * 2, l, m, ql, qr)<br>r_res = self._query(node * 2 + 1, m + 1, r, ql, qr)<br>return self._merge_val(l_res, r_res)<br>def update(self, i: int, val: int) -> None:<br>self._update(1, 0, self._n - 1, i, val)<br>def query(self, ql: int, qr: int) -> int:<br>return self._query(1, 0, self._n - 1, ql, qr)<br>def get(self, i: int) -> int:<br>return self._query(1, 0, self._n - 1, i, i)<br>```<br>```java [sol-Java]<br>// 线段树有两个下标，一个是线段树节点的下标，另一个是线段树维护的区间的下标<br>// 节点的下标：从 1 开始，如果你想改成从 0 开始，需要把左右儿子下标分别改成 node*2+1 和 node*2+2<br>// 区间的下标：从 0 开始<br>class SegmentTree {<br>private final int n;<br>private final long[] tree; // 如果计算结果没有超出 int 范围，可以改成 int<br>// 合并两个 val<br>private long mergeVal(long a, long b) {<br>return Math.max(a, b); // **根据题目修改**<br>}<br>// 线段树维护一个长为 n 的数组（下标从 0 到 n-1），元素初始值为 initVal<br>public SegmentTree(int n, long initVal) {<br>this.n = n;<br>long[] a = new long[n];<br>Arrays.fill(a, initVal);<br>tree = new long[2 << (32 - Integer.numberOfLeadingZeros(n - 1))];<br>build(a, 1, 0, n - 1);<br>}<br>// 线段树维护数组 a<br>public SegmentTree(long[] a) {<br>n = a.length;<br>tree = new long[2 << (32 - Integer.numberOfLeadingZeros(n - 1))];<br>build(a, 1, 0, n - 1);<br>}<br>// 更新 a[i] 为 mergeVal(a[i], val)<br>// 时间复杂度 O(log n)<br>public void update(int i, long val) {<br>update(1, 0, n - 1, i, val);<br>}<br>// 返回用 mergeVal 合并所有 a[i] 的计算结果，其中 i 在闭区间 [ql, qr] 中<br>// 时间复杂度 O(log n)<br>public long query(int ql, int qr) {<br>return query(1, 0, n - 1, ql, qr);<br>}<br>// 获取 a[i] 的值<br>// 时间复杂度 O(log n)<br>public long get(int i) {<br>return query(1, 0, n - 1, i, i);<br>}<br>// 合并左右儿子的 val 到当前节点的 val<br>private void maintain(int node) {<br>tree[node] = mergeVal(tree[node * 2], tree[node * 2 + 1]);<br>}<br>// 用 a 初始化线段树<br>// 时间复杂度 O(n)<br>private void build(long[] a, int node, int l, int r) {<br>if (l == r) { // 叶子<br>tree[node] = a[l]; // 初始化叶节点的值<br>return;<br>}<br>int m = (l + r) / 2;<br>build(a, node * 2, l, m); // 初始化左子树<br>build(a, node * 2 + 1, m + 1, r); // 初始化右子树<br>maintain(node);<br>}<br>private void update(int node, int l, int r, int i, long val) {<br>if (l == r) { // 叶子（到达目标）<br>// 如果想直接替换的话，可以写 tree[node] = val<br>tree[node] = mergeVal(tree[node], val);<br>return;<br>}<br>int m = (l + r) / 2;<br>if (i <= m) { // i 在左子树<br>update(node * 2, l, m, i, val);<br>} else { // i 在右子树<br>update(node * 2 + 1, m + 1, r, i, val);<br>}<br>maintain(node);<br>}<br>private long query(int node, int l, int r, int ql, int qr) {<br>if (ql <= l && r <= qr) { // 当前子树完全在 [ql, qr] 内<br>return tree[node];<br>}<br>int m = (l + r) / 2;<br>if (qr <= m) { // [ql, qr] 在左子树<br>return query(node * 2, l, m, ql, qr);<br>}<br>if (ql > m) { // [ql, qr] 在右子树<br>return query(node * 2 + 1, m + 1, r, ql, qr);<br>}<br>long lRes = query(node * 2, l, m, ql, qr);<br>long rRes = query(node * 2 + 1, m + 1, r, ql, qr);<br>return mergeVal(lRes, rRes);<br>}<br>}<br>```<br>```cpp [sol-C++]<br>// 线段树有两个下标，一个是线段树节点的下标，另一个是线段树维护的区间的下标<br>// 节点的下标：从 1 开始，如果你想改成从 0 开始，需要把左右儿子下标分别改成 node*2+1 和 node*2+2<br>// 区间的下标：从 0 开始<br>template<typename T><br>class SegmentTree {<br>int n;<br>vector<T> tree;<br>// 合并两个 val<br>T merge_val(T a, T b) const {<br>return max(a, b); // **根据题目修改**<br>}<br>// 合并左右儿子的 val 到当前节点的 val<br>void maintain(int node) {<br>tree[node] = merge_val(tree[node * 2], tree[node * 2 + 1]);<br>}<br>// 用 a 初始化线段树<br>// 时间复杂度 O(n)<br>void build(const vector<T>& a, int node, int l, int r) {<br>if (l == r) { // 叶子<br>tree[node] = a[l]; // 初始化叶节点的值<br>return;<br>}<br>int m = (l + r) / 2;<br>build(a, node * 2, l, m); // 初始化左子树<br>build(a, node * 2 + 1, m + 1, r); // 初始化右子树<br>maintain(node);<br>}<br>void update(int node, int l, int r, int i, T val) {<br>if (l == r) { // 叶子（到达目标）<br>// 如果想直接替换的话，可以写 tree[node] = val<br>tree[node] = merge_val(tree[node], val);<br>return;<br>}<br>int m = (l + r) / 2;<br>if (i <= m) {  // i 在左子树<br>update(node * 2, l, m, i, val);<br>} else {  // i 在右子树<br>update(node * 2 + 1, m + 1, r, i, val);<br>}<br>maintain(node);<br>}<br>T query(int node, int l, int r, int ql, int qr) const {<br>if (ql <= l && r <= qr) { // 当前子树完全在 [ql, qr] 内<br>return tree[node];<br>}<br>int m = (l + r) / 2;<br>if (qr <= m) {  // [ql, qr] 在左子树<br>return query(node * 2, l, m, ql, qr);<br>}<br>if (ql > m) {  // [ql, qr] 在右子树<br>return query(node * 2 + 1, m + 1, r, ql, qr);<br>}<br>T l_res = query(node * 2, l, m, ql, qr);<br>T r_res = query(node * 2 + 1, m + 1, r, ql, qr);<br>return merge_val(l_res, r_res);<br>}<br>public:<br>// 线段树维护一个长为 n 的数组（下标从 0 到 n-1），元素初始值为 init_val<br>SegmentTree(int n, T init_val) : SegmentTree(vector<T>(n, init_val)) {}<br>// 线段树维护数组 a<br>SegmentTree(const vector<T>& a) : n(a.size()), tree(2 << bit_width(a.size() - 1)) {<br>build(a, 1, 0, n - 1);<br>}<br>// 更新 a[i] 为 merge_val(a[i], val)<br>// 时间复杂度 O(log n)<br>void update(int i, T val) {<br>update(1, 0, n - 1, i, val);<br>}<br>// 返回用 merge_val 合并所有 a[i] 的计算结果，其中 i 在闭区间 [ql, qr] 中<br>// 时间复杂度 O(log n)<br>T query(int ql, int qr) const {<br>return query(1, 0, n - 1, ql, qr);<br>}<br>// 获取 a[i] 的值<br>// 时间复杂度 O(log n)<br>T get(int i) const {<br>return query(1, 0, n - 1, i, i);<br>}<br>};<br>int main() {<br>SegmentTree t(8, 0LL); // 如果这里写 0LL，那么 SegmentTree 存储的就是 long long 数据<br>t.update(0, 1LL << 60);<br>cout << t.query(0, 7) << endl;<br>vector<int> nums = {3, 1, 4, 1, 5, 9, 2, 6};<br>// 注意：如果要让 SegmentTree 存储 long long 数据，需要传入 vector<long long><br>SegmentTree t2(nums); // 这里 SegmentTree 存储的是 int 数据<br>cout << t2.query(0, 7) << endl;<br>return 0;<br>}<br>```<br>```go [sol-Go]<br>// 线段树有两个下标，一个是线段树节点的下标，另一个是线段树维护的区间的下标<br>// 节点的下标：从 1 开始，如果你想改成从 0 开始，需要把左右儿子下标分别改成 node*2+1 和 node*2+2<br>// 区间的下标：从 0 开始<br>type seg []struct {<br>val int // **根据题目修改**<br>}<br>// 合并两个 val<br>func (seg) mergeVal(a, b int) int {<br>return max(a, b) // **根据题目修改**<br>}<br>// 线段树维护一个长为 n 的数组（下标从 0 到 n-1），元素初始值为 initVal<br>func newSegmentTree(n int, initVal int) seg {<br>a := make([]int, n)<br>for i := range a {<br>a[i] = initVal<br>}<br>return newSegmentTreeWithArray(a)<br>}<br>// 线段树维护数组 a<br>func newSegmentTreeWithArray(a []int) seg {<br>n := len(a)<br>t := make(seg, 2<<bits.Len(uint(n-1)))<br>t.build(a, 1, 0, n-1)<br>return t<br>}<br>// 合并左右儿子的 val 到当前节点的 val<br>func (t seg) maintain(node int) {<br>t[node].val = t.mergeVal(t[node*2].val, t[node*2+1].val)<br>}<br>// 用 a 初始化线段树<br>// 时间复杂度 O(n)<br>func (t seg) build(a []int, node, l, r int) {<br>if l == r { // 叶子<br>t[node].val = a[l] // 初始化叶节点的值<br>return<br>}<br>m := (l + r) / 2<br>t.build(a, node*2, l, m) // 初始化左子树<br>t.build(a, node*2+1, m+1, r) // 初始化右子树<br>t.maintain(node)<br>}<br>// 更新 a[i] 为 mergeVal(a[i], val)<br>// 调用 t.update(1, 0, n-1, i, val)<br>// 0 <= i <= n-1<br>// 时间复杂度 O(log n)<br>func (t seg) update(node, l, r, i int, val int) {<br>if l == r { // 叶子（到达目标）<br>// 如果想直接替换的话，可以写 t[o].val = val<br>t[node].val = t.mergeVal(t[node].val, val)<br>return<br>}<br>m := (l + r) / 2<br>if i <= m { // i 在左子树<br>t.update(node*2, l, m, i, val)<br>} else { // i 在右子树<br>t.update(node*2+1, m+1, r, i, val)<br>}<br>t.maintain(node)<br>}<br>// 返回用 mergeVal 合并所有 a[i] 的计算结果，其中 i 在闭区间 [ql, qr] 中<br>// 调用 t.query(1, 0, n-1, ql, qr)<br>// 如果只想获取 a[i]，可以调用 t.query(1, 0, n-1, i, i)<br>// 0 <= ql <= qr <= n-1<br>// 时间复杂度 O(log n)<br>func (t seg) query(node, l, r, ql, qr int) int {<br>if ql <= l && r <= qr { // 当前子树完全在 [ql, qr] 内<br>return t[node].val<br>}<br>m := (l + r) / 2<br>if qr <= m { // [ql, qr] 在左子树<br>return t.query(node*2, l, m, ql, qr)<br>}<br>if ql > m { // [ql, qr] 在右子树<br>return t.query(node*2+1, m+1, r, ql, qr)<br>}<br>lRes := t.query(node*2, l, m, ql, qr)<br>rRes := t.query(node*2+1, m+1, r, ql, qr)<br>return t.mergeVal(lRes, rRes)<br>}<br>```<br>**思维扩展**：<br>", "isLeaf": true, "children": [{"title": "时间复杂度 O(log n)", "summary": "基础模板代码如下。为方便入门理解，我没有做复杂封装。通用模板代码可以参考 AtCoder Library 的 <a href=\"https://github.com/atcoder/ac-library/blob/master/atcoder/lazysegtree.hpp\">lazysegtree.hpp</a>。<br>```py [sol-Python3]<br>class Node:<br>__slots__ = 'val', 'todo'<br>class LazySegmentTree:<br>_TODO_INIT = 0  # **根据题目修改**<br>def __init__(self, n: int, init_val=0):<br>if isinstance(init_val, int):<br>init_val = [init_val] * n<br>self._n = n<br>self._tree = [Node() for _ in range(2 << (n - 1).bit_length())]<br>self._build(init_val, 1, 0, n - 1)<br>def _merge_val(self, a: int, b: int) -> int:<br>return a + b  # **根据题目修改**<br>def _merge_todo(self, a: int, b: int) -> int:<br>return a + b  # **根据题目修改**<br>def _apply(self, node: int, l: int, r: int, todo: int) -> None:<br>cur = self._tree[node]<br>cur.val += todo * (r - l + 1)  # **根据题目修改**<br>cur.todo = self._merge_todo(todo, cur.todo)<br>def _spread(self, node: int, l: int, r: int) -> None:<br>todo = self._tree[node].todo<br>if todo == self._TODO_INIT:  # 没有需要下传的信息<br>return<br>m = (l + r) // 2<br>self._apply(node * 2, l, m, todo)<br>self._apply(node * 2 + 1, m + 1, r, todo)<br>self._tree[node].todo = self._TODO_INIT  # 下传完毕<br>def _maintain(self, node: int) -> None:<br>self._tree[node].val = self._merge_val(self._tree[node * 2].val, self._tree[node * 2 + 1].val)<br>def _build(self, a: List[int], node: int, l: int, r: int) -> None:<br>self._tree[node].todo = self._TODO_INIT<br>if l == r:  # 叶子<br>self._tree[node].val = a[l]  # 初始化叶节点的值<br>return<br>m = (l + r) // 2<br>self._build(a, node * 2, l, m)  # 初始化左子树<br>self._build(a, node * 2 + 1, m + 1, r)  # 初始化右子树<br>self._maintain(node)<br>def _update(self, node: int, l: int, r: int, ql: int, qr: int, f: int) -> None:<br>if ql <= l and r <= qr:  # 当前子树完全在 [ql, qr] 内<br>self._apply(node, l, r, f)<br>return<br>self._spread(node, l, r)<br>m = (l + r) // 2<br>if ql <= m:  # 更新左子树<br>self._update(node * 2, l, m, ql, qr, f)<br>if qr > m:  # 更新右子树<br>self._update(node * 2 + 1, m + 1, r, ql, qr, f)<br>self._maintain(node)<br>def _query(self, node: int, l: int, r: int, ql: int, qr: int) -> int:<br>if ql <= l and r <= qr:  # 当前子树完全在 [ql, qr] 内<br>return self._tree[node].val<br>self._spread(node, l, r)<br>m = (l + r) // 2<br>if qr <= m:  # [ql, qr] 在左子树<br>return self._query(node * 2, l, m, ql, qr)<br>if ql > m:  # [ql, qr] 在右子树<br>return self._query(node * 2 + 1, m + 1, r, ql, qr)<br>l_res = self._query(node * 2, l, m, ql, qr)<br>r_res = self._query(node * 2 + 1, m + 1, r, ql, qr)<br>return self._merge_val(l_res, r_res)<br>def update(self, ql: int, qr: int, f: int) -> None:<br>self._update(1, 0, self._n - 1, ql, qr, f)<br>def query(self, ql: int, qr: int) -> int:<br>return self._query(1, 0, self._n - 1, ql, qr)<br>```<br>```java [sol-Java]<br>class LazySegmentTree {<br>// 懒标记初始值<br>private static final long TODO_INIT = 0; // **根据题目修改**<br>private static final class Node {<br>long val; // **根据题目修改**<br>long todo;<br>}<br>// 合并两个 val<br>private long mergeVal(long a, long b) {<br>return a + b; // **根据题目修改**<br>}<br>// 合并两个懒标记<br>private long mergeTodo(long a, long b) {<br>return a + b; // **根据题目修改**<br>}<br>// 把懒标记作用到 node 子树（本例为区间加）<br>private void apply(int node, int l, int r, long todo) {<br>Node cur = tree[node];<br>// 计算 tree[node] 区间的整体变化<br>cur.val += todo * (r - l + 1); // **根据题目修改**<br>cur.todo = mergeTodo(todo, cur.todo);<br>}<br>private final int n;<br>private final Node[] tree;<br>// 线段树维护一个长为 n 的数组（下标从 0 到 n-1），元素初始值为 initVal<br>public LazySegmentTree(int n, long initVal) {<br>this.n = n;<br>long[] a = new long[n];<br>Arrays.fill(a, initVal);<br>tree = new Node[2 << (32 - Integer.numberOfLeadingZeros(n - 1))];<br>build(a, 1, 0, n - 1);<br>}<br>// 线段树维护数组 a<br>public LazySegmentTree(long[] a) {<br>n = a.length;<br>tree = new Node[2 << (32 - Integer.numberOfLeadingZeros(n - 1))];<br>build(a, 1, 0, n - 1);<br>}<br>// 用 f 更新 [ql, qr] 中的每个 a[i]<br>// 0 <= ql <= qr <= n-1<br>// 时间复杂度 O(log n)<br>public void update(int ql, int qr, long f) {<br>update(1, 0, n - 1, ql, qr, f);<br>}<br>// 返回用 mergeVal 合并所有 a[i] 的计算结果，其中 i 在闭区间 [ql, qr] 中<br>// 0 <= ql <= qr <= n-1<br>// 时间复杂度 O(log n)<br>public long query(int ql, int qr) {<br>return query(1, 0, n - 1, ql, qr);<br>}<br>// 把当前节点的懒标记下传给左右儿子<br>private void spread(int node, int l, int r) {<br>long todo = tree[node].todo;<br>if (todo == TODO_INIT) { // 没有需要下传的信息<br>return;<br>}<br>int m = (l + r) / 2;<br>apply(node * 2, l, m, todo);<br>apply(node * 2 + 1, m + 1, r, todo);<br>tree[node].todo = TODO_INIT; // 下传完毕<br>}<br>// 合并左右儿子的 val 到当前节点的 val<br>private void maintain(int node) {<br>tree[node].val = mergeVal(tree[node * 2].val, tree[node * 2 + 1].val);<br>}<br>// 用 a 初始化线段树<br>// 时间复杂度 O(n)<br>private void build(long[] a, int node, int l, int r) {<br>tree[node] = new Node();<br>tree[node].todo = TODO_INIT;<br>if (l == r) { // 叶子<br>tree[node].val = a[l]; // 初始化叶节点的值<br>return;<br>}<br>int m = (l + r) / 2;<br>build(a, node * 2, l, m); // 初始化左子树<br>build(a, node * 2 + 1, m + 1, r); // 初始化右子树<br>maintain(node);<br>}<br>private void update(int node, int l, int r, int ql, int qr, long f) {<br>if (ql <= l && r <= qr) { // 当前子树完全在 [ql, qr] 内<br>apply(node, l, r, f);<br>return;<br>}<br>spread(node, l, r);<br>int m = (l + r) / 2;<br>if (ql <= m) { // 更新左子树<br>update(node * 2, l, m, ql, qr, f);<br>}<br>if (qr > m) { // 更新右子树<br>update(node * 2 + 1, m + 1, r, ql, qr, f);<br>}<br>maintain(node);<br>}<br>private long query(int node, int l, int r, int ql, int qr) {<br>if (ql <= l && r <= qr) { // 当前子树完全在 [ql, qr] 内<br>return tree[node].val;<br>}<br>spread(node, l, r);<br>int m = (l + r) / 2;<br>if (qr <= m) { // [ql, qr] 在左子树<br>return query(node * 2, l, m, ql, qr);<br>}<br>if (ql > m) { // [ql, qr] 在右子树<br>return query(node * 2 + 1, m + 1, r, ql, qr);<br>}<br>long lRes = query(node * 2, l, m, ql, qr);<br>long rRes = query(node * 2 + 1, m + 1, r, ql, qr);<br>return mergeVal(lRes, rRes);<br>}<br>}<br>```<br>```cpp [sol-C++]<br>template<typename T, typename F><br>class LazySegmentTree {<br>// 懒标记初始值<br>const F TODO_INIT = 0; // **根据题目修改**<br>struct Node {<br>T val; // **根据题目修改**<br>F todo;<br>};<br>int n;<br>vector<Node> tree;<br>// 合并两个 val<br>T merge_val(T a, T b) const {<br>return a + b; // **根据题目修改**<br>}<br>// 合并两个懒标记<br>F merge_todo(F a, F b) const {<br>return a + b; // **根据题目修改**<br>}<br>// 把懒标记作用到 node 子树（本例为区间加）<br>void apply(int node, int l, int r, F todo) {<br>Node& cur = tree[node];<br>// 计算 tree[node] 区间的整体变化<br>cur.val += todo * (r - l + 1); // **根据题目修改**<br>cur.todo = merge_todo(todo, cur.todo);<br>}<br>// 把当前节点的懒标记下传给左右儿子<br>void spread(int node, int l, int r) {<br>Node& cur = tree[node];<br>F todo = cur.todo;<br>if (todo == TODO_INIT) { // 没有需要下传的信息<br>return;<br>}<br>int m = (l + r) / 2;<br>apply(node * 2, l, m, todo);<br>apply(node * 2 + 1, m + 1, r, todo);<br>cur.todo = TODO_INIT; // 下传完毕<br>}<br>// 合并左右儿子的 val 到当前节点的 val<br>void maintain(int node) {<br>tree[node].val = merge_val(tree[node * 2].val, tree[node * 2 + 1].val);<br>}<br>// 用 a 初始化线段树<br>// 时间复杂度 O(n)<br>void build(const vector<T>& a, int node, int l, int r) {<br>Node& cur = tree[node];<br>cur.todo = TODO_INIT;<br>if (l == r) { // 叶子<br>cur.val = a[l]; // 初始化叶节点的值<br>return;<br>}<br>int m = (l + r) / 2;<br>build(a, node * 2, l, m); // 初始化左子树<br>build(a, node * 2 + 1, m + 1, r); // 初始化右子树<br>maintain(node);<br>}<br>void update(int node, int l, int r, int ql, int qr, F f) {<br>if (ql <= l && r <= qr) { // 当前子树完全在 [ql, qr] 内<br>apply(node, l, r, f);<br>return;<br>}<br>spread(node, l, r);<br>int m = (l + r) / 2;<br>if (ql <= m) { // 更新左子树<br>update(node * 2, l, m, ql, qr, f);<br>}<br>if (qr > m) { // 更新右子树<br>update(node * 2 + 1, m + 1, r, ql, qr, f);<br>}<br>maintain(node);<br>}<br>T query(int node, int l, int r, int ql, int qr) {<br>if (ql <= l && r <= qr) { // 当前子树完全在 [ql, qr] 内<br>return tree[node].val;<br>}<br>spread(node, l, r);<br>int m = (l + r) / 2;<br>if (qr <= m) { // [ql, qr] 在左子树<br>return query(node * 2, l, m, ql, qr);<br>}<br>if (ql > m) { // [ql, qr] 在右子树<br>return query(node * 2 + 1, m + 1, r, ql, qr);<br>}<br>T l_res = query(node * 2, l, m, ql, qr);<br>T r_res = query(node * 2 + 1, m + 1, r, ql, qr);<br>return merge_val(l_res, r_res);<br>}<br>public:<br>// 线段树维护一个长为 n 的数组（下标从 0 到 n-1），元素初始值为 init_val<br>LazySegmentTree(int n, T init_val = 0) : LazySegmentTree(vector<T>(n, init_val)) {}<br>// 线段树维护数组 a<br>LazySegmentTree(const vector<T>& a) : n(a.size()), tree(2 << bit_width(a.size() - 1)) {<br>build(a, 1, 0, n - 1);<br>}<br>// 用 f 更新 [ql, qr] 中的每个 a[i]<br>// 0 <= ql <= qr <= n-1<br>// 时间复杂度 O(log n)<br>void update(int ql, int qr, F f) {<br>update(1, 0, n - 1, ql, qr, f);<br>}<br>// 返回用 merge_val 合并所有 a[i] 的计算结果，其中 i 在闭区间 [ql, qr] 中<br>// 0 <= ql <= qr <= n-1<br>// 时间复杂度 O(log n)<br>T query(int ql, int qr) {<br>return query(1, 0, n - 1, ql, qr);<br>}<br>};<br>int main() {<br>LazySegmentTree<long long, long long> t(8); // 默认值为 0<br>t.update(3, 5, 100);<br>t.update(4, 6, 10);<br>cout << t.query(0, 7) << endl;<br>vector<long long> nums = {3, 1, 4, 1, 5, 9, 2, 6};<br>LazySegmentTree<long long, long long> t2(nums);<br>t2.update(3, 5, 1);<br>t2.update(4, 6, 1);<br>cout << t2.query(0, 7) << endl;<br>return 0;<br>}<br>```<br>```go [sol-Go]<br>// 懒标记初始值<br>const todoInit int = 0 // **根据题目修改**<br>type lazySeg []struct {<br>val  int // **根据题目修改**<br>todo int<br>}<br>// 合并两个 val<br>func (lazySeg) mergeVal(a, b int) int {<br>return a + b // **根据题目修改**<br>}<br>// 合并两个懒标记<br>func (lazySeg) mergeTodo(a, b int) int {<br>return a + b // **根据题目修改**<br>}<br>// 把懒标记作用到 node 子树（本例为区间加）<br>func (t lazySeg) apply(node, l, r int, todo int) {<br>cur := &t[node]<br>// 计算 tree[node] 区间的整体变化<br>cur.val += todo * (r - l + 1) // **根据题目修改**<br>cur.todo = t.mergeTodo(todo, cur.todo)<br>}<br>// 线段树维护一个长为 n 的数组（下标从 0 到 n-1），元素初始值为 initVal<br>func newLazySegmentTree(n int, initVal int) lazySeg {<br>a := make([]int, n)<br>for i := range a {<br>a[i] = initVal<br>}<br>return newLazySegmentTreeWithArray(a)<br>}<br>// 线段树维护数组 a<br>func newLazySegmentTreeWithArray(a []int) lazySeg {<br>n := len(a)<br>t := make(lazySeg, 2<<bits.Len(uint(n-1)))<br>t.build(a, 1, 0, n-1)<br>return t<br>}<br>// 把当前节点的懒标记下传给左右儿子<br>func (t lazySeg) spread(node, l, r int) {<br>// 类似「断点续传」，接着完成之前没完成的下传任务<br>todo := t[node].todo<br>if todo == todoInit { // 没有需要下传的信息<br>return<br>}<br>m := (l + r) / 2<br>t.apply(node*2, l, m, todo)<br>t.apply(node*2+1, m+1, r, todo)<br>t[node].todo = todoInit // 下传完毕<br>}<br>// 合并左右儿子的 val 到当前节点的 val<br>func (t lazySeg) maintain(node int) {<br>t[node].val = t.mergeVal(t[node*2].val, t[node*2+1].val)<br>}<br>// 用 a 初始化线段树<br>// 时间复杂度 O(n)<br>func (t lazySeg) build(a []int, node, l, r int) {<br>t[node].todo = todoInit<br>if l == r { // 叶子<br>t[node].val = a[l] // 初始化叶节点的值<br>return<br>}<br>m := (l + r) / 2<br>t.build(a, node*2, l, m) // 初始化左子树<br>t.build(a, node*2+1, m+1, r) // 初始化右子树<br>t.maintain(node)<br>}<br>// 用 f 更新 [ql, qr] 中的每个 a[i]<br>// 调用 t.update(1, 0, n-1, ql, qr, f)<br>// 0 <= ql <= qr <= n-1<br>// 时间复杂度 O(log n)<br>func (t lazySeg) update(node, l, r, ql, qr int, f int) {<br>if ql <= l && r <= qr { // 当前子树完全在 [ql, qr] 内<br>t.apply(node, l, r, f)<br>return<br>}<br>t.spread(node, l, r)<br>m := (l + r) / 2<br>if ql <= m { // 更新左子树<br>t.update(node*2, l, m, ql, qr, f)<br>}<br>if qr > m { // 更新右子树<br>t.update(node*2+1, m+1, r, ql, qr, f)<br>}<br>t.maintain(node)<br>}<br>// 返回用 mergeVal 合并所有 a[i] 的计算结果，其中 i 在闭区间 [ql, qr] 中<br>// 调用 t.query(1, 0, n-1, ql, qr)<br>// 0 <= ql <= qr <= n-1<br>// 时间复杂度 O(log n)<br>func (t lazySeg) query(node, l, r, ql, qr int) int {<br>if ql <= l && r <= qr { // 当前子树完全在 [ql, qr] 内<br>return t[node].val<br>}<br>t.spread(node, l, r)<br>m := (l + r) / 2<br>if qr <= m { // [ql, qr] 在左子树<br>return t.query(node*2, l, m, ql, qr)<br>}<br>if ql > m { // [ql, qr] 在右子树<br>return t.query(node*2+1, m+1, r, ql, qr)<br>}<br>lRes := t.query(node*2, l, m, ql, qr)<br>rRes := t.query(node*2+1, m+1, r, ql, qr)<br>return t.mergeVal(lRes, rRes)<br>}<br>```<br>", "isLeaf": true, "children": [], "problems": [{"id": 2569, "title": "2569. 更新数组后处理求和查询", "slug": "/handling-sum-queries-after-update/", "src": "https://leetcode.cn/problems/handling-sum-queries-after-update/", "solution": null, "score": 2397.8728428256, "isPremium": false}, {"id": 1622, "title": "1622. 奇妙序列", "slug": "/fancy-sequence/", "src": "https://leetcode.cn/problems/fancy-sequence/", "solution": null, "score": 2476.451764287, "isPremium": false}, {"id": 2502, "title": "2502. 设计内存分配器", "slug": "/design-memory-allocator/", "src": "https://leetcode.cn/problems/design-memory-allocator/", "solution": null, "score": 1745.5352025872, "isPremium": false}, {"id": 2589, "title": "2589. 完成所有任务的最少时间", "slug": "/minimum-time-to-complete-all-tasks/", "src": "https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/", "solution": null, "score": 2380.5983169295, "isPremium": false}, {"id": 2547, "title": "2547. 拆分数组的最小代价", "slug": "/minimum-cost-to-split-an-array/", "src": "https://leetcode.cn/problems/minimum-cost-to-split-an-array/", "solution": null, "score": 2019.9859462755, "isPremium": false}, {"id": 850, "title": "850. 矩形面积 II", "slug": "/rectangle-area-ii/", "src": "https://leetcode.cn/problems/rectangle-area-ii/", "solution": null, "score": 2235.9672341699, "isPremium": false}, {"id": 3454, "title": "3454. 分割正方形 II", "slug": "/separate-squares-ii/", "src": "https://leetcode.cn/problems/separate-squares-ii/", "solution": null, "score": null, "isPremium": false}, {"id": 2916, "title": "2916. 子数组不同元素数目的平方和 II", "slug": "/subarrays-distinct-element-sum-of-squares-ii/", "src": "https://leetcode.cn/problems/subarrays-distinct-element-sum-of-squares-ii/", "solution": null, "score": 2816.0706257586, "isPremium": false}, {"id": "LCP 05", "title": "LCP 05. 发 LeetCoin", "slug": "/coin-bonus/", "src": "https://leetcode.cn/problems/coin-bonus/", "solution": null, "score": null, "isPremium": false}, {"id": "LCP 27", "title": "LCP 27. 黑盒光线反射", "slug": "/IQvJ9i/", "src": "https://leetcode.cn/problems/IQvJ9i/", "solution": null, "score": null, "isPremium": false}]}, {"title": "§8.5 动态开点线段树", "summary": "部分题目也可以用**珂朵莉树**解决。<br>", "isLeaf": true, "children": [], "problems": [{"id": 699, "title": "699. 掉落的方块", "slug": "/falling-squares/", "src": "https://leetcode.cn/problems/falling-squares/", "solution": null, "score": null, "isPremium": false}, {"id": 715, "title": "715. Range 模块", "slug": "/range-module/", "src": "https://leetcode.cn/problems/range-module/", "solution": null, "score": null, "isPremium": false}, {"id": 729, "title": "729. 我的日程安排表 I", "slug": "/my-calendar-i/", "src": "https://leetcode.cn/problems/my-calendar-i/", "solution": null, "score": null, "isPremium": false}, {"id": 731, "title": "731. 我的日程安排表 II", "slug": "/my-calendar-ii/", "src": "https://leetcode.cn/problems/my-calendar-ii/", "solution": null, "score": null, "isPremium": false}, {"id": 732, "title": "732. 我的日程安排表 III", "slug": "/my-calendar-iii/", "src": "https://leetcode.cn/problems/my-calendar-iii/", "solution": null, "score": null, "isPremium": false}, {"id": 2276, "title": "2276. 统计区间中的整数数目", "slug": "/count-integers-in-intervals/", "src": "https://leetcode.cn/problems/count-integers-in-intervals/", "solution": null, "score": 2222.4805422748, "isPremium": false}, {"id": 2770, "title": "2770. 达到末尾下标所需的最大跳跃次数", "slug": "/maximum-number-of-jumps-to-reach-the-last-index/", "src": "https://leetcode.cn/problems/maximum-number-of-jumps-to-reach-the-last-index/", "solution": null, "score": 1533.47383662, "isPremium": false}]}, {"title": "专题：离线算法", "summary": "把询问**排序**，通过改变回答询问的顺序，使问题更容易处理。<br>> 相应的，**在线算法**就是按照 $\\textit{queries}$ 的顺序一个一个处理。<br>", "isLeaf": true, "children": [], "problems": [{"id": 2343, "title": "2343. 裁剪数字后查询第 K 小的数字", "slug": "/query-kth-smallest-trimmed-number/", "src": "https://leetcode.cn/problems/query-kth-smallest-trimmed-number/", "solution": null, "score": 1651.569267834, "isPremium": false}, {"id": 2070, "title": "2070. 每一个查询的最大美丽值", "slug": "/most-beautiful-item-for-each-query/", "src": "https://leetcode.cn/problems/most-beautiful-item-for-each-query/", "solution": null, "score": 1724.1545485476, "isPremium": false}, {"id": 1847, "title": "1847. 最近的房间", "slug": "/closest-room/", "src": "https://leetcode.cn/problems/closest-room/", "solution": null, "score": 2081.7518764643, "isPremium": false}, {"id": 2503, "title": "2503. 矩阵查询可获得的最大分数", "slug": "/maximum-number-of-points-from-grid-queries/", "src": "https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/", "solution": null, "score": 2195.6540241654, "isPremium": false}, {"id": 1851, "title": "1851. 包含每个查询的最小区间", "slug": "/minimum-interval-to-include-each-query/", "src": "https://leetcode.cn/problems/minimum-interval-to-include-each-query/", "solution": null, "score": 2286.1378742318, "isPremium": false}, {"id": 1697, "title": "1697. 检查边长度限制的路径是否存在", "slug": "/checking-existence-of-edge-length-limited-paths/", "src": "https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/", "solution": null, "score": 2300.1557840589, "isPremium": false}, {"id": 2940, "title": "2940. 找到 Alice 和 Bob 可以相遇的建筑", "slug": "/find-building-where-alice-and-bob-can-meet/", "src": "https://leetcode.cn/problems/find-building-where-alice-and-bob-can-meet/", "solution": null, "score": 2327.4743300299, "isPremium": false}, {"id": 2747, "title": "2747. 统计没有收到请求的服务器数目", "slug": "/count-zero-request-servers/", "src": "https://leetcode.cn/problems/count-zero-request-servers/", "solution": null, "score": 2405.3375364501, "isPremium": false}, {"id": 1938, "title": "1938. 查询最大基因差", "slug": "/maximum-genetic-difference-query/", "src": "https://leetcode.cn/problems/maximum-genetic-difference-query/", "solution": null, "score": 2502.5176603922, "isPremium": false}, {"id": 2736, "title": "2736. 最大和查询", "slug": "/maximum-sum-queries/", "src": "https://leetcode.cn/problems/maximum-sum-queries/", "solution": null, "score": 2533.2830157959, "isPremium": false}, {"id": 3382, "title": "3382. 用点构造面积最大的矩形 II", "slug": "/maximum-area-rectangle-with-point-constraints-ii/", "src": "https://leetcode.cn/problems/maximum-area-rectangle-with-point-constraints-ii/", "solution": null, "score": 2722.8634460016, "isPremium": false}]}], "problems": [{"id": 3479, "title": "3479. 将水果装入篮子 III", "slug": "/fruits-into-baskets-iii/", "src": "https://leetcode.cn/problems/fruits-into-baskets-iii/", "solution": null, "score": null, "isPremium": false}, {"id": 2940, "title": "2940. 找到 Alice 和 Bob 可以相遇的建筑", "slug": "/find-building-where-alice-and-bob-can-meet/", "src": "https://leetcode.cn/problems/find-building-where-alice-and-bob-can-meet/", "solution": null, "score": 2327.4743300299, "isPremium": false}, {"id": 2286, "title": "2286. 以组为单位订音乐会的门票", "slug": "/booking-concert-tickets-in-groups/", "src": "https://leetcode.cn/problems/booking-concert-tickets-in-groups/", "solution": null, "score": 2470.2118194809, "isPremium": false}, {"id": 3161, "title": "3161. 物块放置查询", "slug": "/block-placement-queries/", "src": "https://leetcode.cn/problems/block-placement-queries/", "solution": null, "score": 2513.0284514744, "isPremium": false}, {"id": 2213, "title": "2213. 由单个字符重复的最长子字符串", "slug": "/longest-substring-of-one-repeating-character/", "src": "https://leetcode.cn/problems/longest-substring-of-one-repeating-character/", "solution": null, "score": 2628.7957821141, "isPremium": false}, {"id": 3165, "title": "3165. 不包含相邻元素的子序列的最大和", "slug": "/maximum-sum-of-subsequence-with-non-adjacent-elements/", "src": "https://leetcode.cn/problems/maximum-sum-of-subsequence-with-non-adjacent-elements/", "solution": null, "score": 2697.6486586982, "isPremium": false}, {"id": 3410, "title": "3410. 删除所有值为某个元素后的最大子数组和", "slug": "/maximize-subarray-sum-after-removing-all-occurrences-of-one-element/", "src": "https://leetcode.cn/problems/maximize-subarray-sum-after-removing-all-occurrences-of-one-element/", "solution": null, "score": 2843.655465882, "isPremium": false}, {"id": "LCP 81", "title": "LCP 81. 与非的谜题", "slug": "/ryfUiz/", "src": "https://leetcode.cn/problems/ryfUiz/", "solution": null, "score": null, "isPremium": false}, {"id": 2407, "title": "2407. 最长递增子序列 II", "slug": "/longest-increasing-subsequence-ii/", "src": "https://leetcode.cn/problems/longest-increasing-subsequence-ii/", "solution": null, "score": 2280.3143643878, "isPremium": false}, {"id": 1157, "title": "1157. 子数组中占绝大多数的元素", "slug": "/online-majority-element-in-subarray/", "src": "https://leetcode.cn/problems/online-majority-element-in-subarray/", "solution": null, "score": 2205.4304373587, "isPremium": false}]}]}